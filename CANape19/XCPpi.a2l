/* generated by ASAP2 Studio 2.2.5.8070 */
// @@@@ File written by CANAPE_VERSION 18 0 30 @@@@ 

ASAP2_VERSION 1 71
/begin PROJECT XCPpi "RaspberryPi XCP demo"

  /begin HEADER ""
    VERSION "1.0"
  /end HEADER

  /begin MODULE RaspberryPi4 ""

    /begin A2ML

        struct UDP_Parameters {
          uint;  /* XCP on UDP version, currently 0x0100 */
          uint;  /* PORT */
          taggedunion {
            "HOST_NAME" char[256];
            "ADDRESS" char[15];
          };
        };

        struct SIMULINK_Parameters {
          taggedstruct {
            "MODEL_NAME" char[64];
          };
        };

        struct Protocol_Layer {
          uint;  /* XCP protocol layer version, currently 0x103 */
          uint;  /* T1 [ms] Time-out of the standard CTO, for example CONNECT*/
          uint;  /* T2 [ms] Time-out of the checksum calculation*/
          uint;  /* T3 [ms] Time-out of the non-volatile memory programming: PROGRAM_START, PROGRAM_VERIFY, PROGRAM_PREPARE*/
          uint;  /* T4 [ms] Time-out of the non-volatile memory programming: PROGRAM_CLEAR*/
          uint;  /* T5 [ms] Time-out of the non-volatile memory programming: PROGRAM, PROGRAM_RESET, PROGRAM_MAX*/
          uint;  /* T6 [ms] Time-out of the command CONNECT(USER_DEFINED)*/
          uint;  /* T7 [ms] Time-out of the pre-action*/
          uchar;  /* MAX_CTO: Indicates the maximum length of a CTO packet in bytes.*/
          uint;  /* MAX_DTO: Indicates the maximum length of a DTO packet in bytes.*/
          enum {
            "BYTE_ORDER_MSB_LAST" = 0,
            "BYTE_ORDER_MSB_FIRST" = 1
          };  /* BYTE_ORDER: BYTE_ORDER_MSB_LAST = Intel, BYTE_ORDER_MSB_FIRST = Motorola*/
          enum {
            "ADDRESS_GRANULARITY_BYTE" = 1,
            "ADDRESS_GRANULARITY_WORD" = 2,
            "ADDRESS_GRANULARITY_DWORD" = 4
          };  /*The address granularity indicates the size of an element contained at a single address.*/
          taggedstruct {
            ("OPTIONAL_CMD" enum {
              "GET_COMM_MODE_INFO" = 251,
              "GET_ID" = 250,
              "SET_REQUEST" = 249,
              "GET_SEED" = 248,
              "UNLOCK" = 247,
              "SET_MTA" = 246,
              "UPLOAD" = 245,
              "SHORT_UPLOAD" = 244,
              "BUILD_CHECKSUM" = 243,
              "TRANSPORT_LAYER_CMD" = 242,
              "USER_CMD" = 241,
              "DOWNLOAD" = 240,
              "DOWNLOAD_NEXT" = 239,
              "DOWNLOAD_MAX" = 238,
              "SHORT_DOWNLOAD" = 237,
              "MODIFY_BITS" = 236,
              "SET_CAL_PAGE" = 235,
              "GET_CAL_PAGE" = 234,
              "GET_PAG_PROCESSOR_INFO" = 233,
              "GET_SEGMENT_INFO" = 232,
              "GET_PAGE_INFO" = 231,
              "SET_SEGMENT_MODE" = 230,
              "GET_SEGMENT_MODE" = 229,
              "COPY_CAL_PAGE" = 228,
              "CLEAR_DAQ_LIST" = 227,
              "SET_DAQ_PTR" = 226,
              "WRITE_DAQ" = 225,
              "SET_DAQ_LIST_MODE" = 224,
              "GET_DAQ_LIST_MODE" = 223,
              "START_STOP_DAQ_LIST" = 222,
              "START_STOP_SYNCH" = 221,
              "GET_DAQ_CLOCK" = 220,
              "READ_DAQ" = 219,
              "GET_DAQ_PROCESSOR_INFO" = 218,
              "GET_DAQ_RESOLUTION_INFO" = 217,
              "GET_DAQ_LIST_INFO" = 216,
              "GET_DAQ_EVENT_INFO" = 215,
              "FREE_DAQ" = 214,
              "ALLOC_DAQ" = 213,
              "ALLOC_ODT" = 212,
              "ALLOC_ODT_ENTRY" = 211,
              "PROGRAM_START" = 210,
              "PROGRAM_CLEAR" = 209,
              "PROGRAM" = 208,
              "PROGRAM_RESET" = 207,
              "GET_PGM_PROCESSOR_INFO" = 206,
              "GET_SECTOR_INFO" = 205,
              "PROGRAM_PREPARE" = 204,
              "PROGRAM_FORMAT" = 203,
              "PROGRAM_NEXT" = 202,
              "PROGRAM_MAX" = 201,
              "PROGRAM_VERIFY" = 200,
              "WRITE_DAQ_MULTIPLE" = 199,
              "TIME_CORRELATION_PROPERTIES" = 198,
              "DTO_CTR_PROPERTIES" = 197
            })*;  /* XCP-Code of optional command supported by the slave*/
            "COMMUNICATION_MODE_SUPPORTED" taggedunion {
              "BLOCK" taggedstruct {
                "SLAVE" ;
                "MASTER" struct {
                  uchar;  /* MAX_BS: Indicates the maximum allowed block size as the number of consecutive command packets in a block sequence*/
                  uchar;  /* MIN_ST: Indicates the required minimum separation time between the packets of a block transfer from the master device to the slave device in units of 100 ms*/
                };
              };
              "INTERLEAVED" uchar;  /* QUEUE_SIZE: indicates the maximum number of consecutive command packets the master can send to the receipt queue of the slave*/
            };
            "SEED_AND_KEY_EXTERNAL_FUNCTION" char[256];  /* Name of the Seed&Key function*/
            "MAX_DTO_STIM" uint;  /* overrules MAX_DTO see above for STIM use case */
            block "ECU_STATES" taggedstruct {
              (block "STATE" struct {
                uchar;  /* STATE_NUMBER */
                char[100];  /* STATE_NAME */
                enum {
                  "NOT_ACTIVE" = 0,
                  "ACTIVE" = 1
                };
                enum {
                  "NOT_ACTIVE" = 0,
                  "ACTIVE" = 1
                };  /* DAQ RESOURCE */
                enum {
                  "NOT_ACTIVE" = 0,
                  "ACTIVE" = 1
                };  /* STIM RESOURCE */
                enum {
                  "NOT_ACTIVE" = 0,
                  "ACTIVE" = 1
                };  /* PGM RESOURCE */
                taggedstruct {
                  (block "MEMORY_ACCESS" struct {
                    uchar;  /* SEGMENT_NUMBER */
                    uchar;  /* PAGE_NUMBER */
                    enum {
                      "READ_ACCESS_NOT_ALLOWED" = 0,
                      "READ_ACCESS_ALLOWED" = 1
                    };
                    enum {
                      "WRITE_ACCESS_NOT_ALLOWED" = 0,
                      "WRITE_ACCESS_ALLOWED" = 1
                    };
                  })*;
                };
              })*;
            };
          };
        };

        struct Daq {
          enum {
            "STATIC" = 0,
            "DYNAMIC" = 1
          };  /*The flag indicates whether the DAQ lists that are not PREDEFINED shall be configured statically or dynamically*/
          uint;  /* MAX_DAQ: Total number of available DAQ lists*/
          uint;  /* MAX_EVENT_CHANNEL: Total number of available event channels*/
          uchar;  /* MIN_DAQ: Total number of predefined DAQ lists*/
          enum {
            "OPTIMISATION_TYPE_DEFAULT" = 0,
            "OPTIMISATION_TYPE_ODT_TYPE_16" = 1,
            "OPTIMISATION_TYPE_ODT_TYPE_32" = 2,
            "OPTIMISATION_TYPE_ODT_TYPE_64" = 3,
            "OPTIMISATION_TYPE_ODT_TYPE_ALIGNMENT" = 4,
            "OPTIMISATION_TYPE_MAX_ENTRY_SIZE" = 5
          };  /* Indicate the Type of Optimisation Method the master preferably should use.*/
          enum {
            "ADDRESS_EXTENSION_FREE" = 0,
            "ADDRESS_EXTENSION_ODT" = 1,
            "ADDRESS_EXTENSION_DAQ" = 3
          };  /*The flag indicates whether the address extension of all entries within one ODT or within one DAQ must be the same.*/
          enum {
            "IDENTIFICATION_FIELD_TYPE_ABSOLUTE" = 0,
            "IDENTIFICATION_FIELD_TYPE_RELATIVE_BYTE" = 1,
            "IDENTIFICATION_FIELD_TYPE_RELATIVE_WORD" = 2,
            "IDENTIFICATION_FIELD_TYPE_RELATIVE_WORD_ALIGNED" = 3
          };  /* The type of Identification Field the slave will use when transferring DAQ Packets to the master*/
          enum {
            "GRANULARITY_ODT_ENTRY_SIZE_DAQ_BYTE" = 1,
            "GRANULARITY_ODT_ENTRY_SIZE_DAQ_WORD" = 2,
            "GRANULARITY_ODT_ENTRY_SIZE_DAQ_DWORD" = 4,
            "GRANULARITY_ODT_ENTRY_SIZE_DAQ_DLONG" = 8
          };  /* Granularity for size of ODT entry*/
          uchar;  /* MAX_ODT_ENTRY_SIZE_DAQ Maximum size of ODT entry (DIRECTION = DAQ)*/
          enum {
            "NO_OVERLOAD_INDICATION" = 0,
            "OVERLOAD_INDICATION_PID" = 1,
            "OVERLOAD_INDICATION_EVENT" = 2
          };  /*OVERLOAD_INDICATION_PID: This means the higest bit is set in the PID, when an overload occurs
OVERLOAD_INDICATION_EVENT: This means an event is set, when an overload occurs*/
          taggedstruct {
            "DAQ_ALTERNATING_SUPPORTED" uint;  /*This flag selects the alternating display mode.*/
            "PRESCALER_SUPPORTED" ;  /*This flag indicates that all DAQ lists support the prescaler for reducing the transmission period.*/
            "RESUME_SUPPORTED" ;  /*This  flag indicates that all DAQ lists can be put in RESUME mode.*/
            "STORE_DAQ_SUPPORTED" ;  /*This flag indicates that the slave can store DAQ configurations.*/
            "DTO_CTR_FIELD_SUPPORTED" ;
            block "STIM" struct {
              enum {
                "GRANULARITY_ODT_ENTRY_SIZE_STIM_BYTE" = 1,
                "GRANULARITY_ODT_ENTRY_SIZE_STIM_WORD" = 2,
                "GRANULARITY_ODT_ENTRY_SIZE_STIM_DWORD" = 4,
                "GRANULARITY_ODT_ENTRY_SIZE_STIM_DLONG" = 8
              };  /* Granularity for size of ODT entry direction STIM*/
              uchar;  /* MAX_ODT_ENTRY_SIZE_STIM Maximum size of ODT entry (DIRECTION = STIM)*/
              taggedstruct {
                "BIT_STIM_SUPPORTED" ;  /*The flag indicates  whether  bitwise  data  stimulation  through BIT_OFFSET in WRITE_DAQ is supported.*/
                "MIN_ST_STIM" uchar;  /*Separation time between DTOs time in units of 100 microseconds*/
              };
            };
            block "TIMESTAMP_SUPPORTED" struct {
              uint;  /*The timestamp will increment by TIMESTAMP_TICKS per unit and wrap around if an overflow occurs.*/
              enum {
                "NO_TIME_STAMP" = 0,
                "SIZE_BYTE" = 1,
                "SIZE_WORD" = 2,
                "SIZE_DWORD" = 4
              };  /*Timestamp size in bytes*/
              enum {
                "UNIT_1NS" = 0,
                "UNIT_10NS" = 1,
                "UNIT_100NS" = 2,
                "UNIT_1US" = 3,
                "UNIT_10US" = 4,
                "UNIT_100US" = 5,
                "UNIT_1MS" = 6,
                "UNIT_10MS" = 7,
                "UNIT_100MS" = 8,
                "UNIT_1S" = 9,
                "UNIT_1PS" = 10,
                "UNIT_10PS" = 11,
                "UNIT_100PS" = 12
              };  /*Ticks per unit*/
              taggedstruct {
                "TIMESTAMP_FIXED" ;
              };  /* TIMESTAMP_FIXED flag indicates that the Slave always will send DTO Packets in time stamped mode.*/
            };
            "PID_OFF_SUPPORTED" ;  /*Flag in DAQ_PROPERTIES indicates that transfer of DTO Packets without Identification Field is possible.*/
            "MAX_DAQ_TOTAL" uint;
            "MAX_ODT_TOTAL" uint;
            "MAX_ODT_DAQ_TOTAL" uint;
            "MAX_ODT_STIM_TOTAL" uint;
            "MAX_ODT_ENTRIES_TOTAL" uint;
            "MAX_ODT_ENTRIES_DAQ_TOTAL" uint;
            "MAX_ODT_ENTRIES_STIM_TOTAL" uint;
            "CPU_LOAD_MAX_TOTAL" float;
            "CORE_LOAD_MAX_TOTAL" float;  /* max load of all cores */
            (block "CORE_LOAD_MAX" struct {
              uint;  /* CORE_NR: core reference number */
              float;  /* CORE_LOAD_MAX: max load of core(CORE_NR) */
            })*;
            block "DAQ_MEMORY_CONSUMPTION" struct {
              ulong;  /* "DAQ_MEMORY_LIMIT"*/
              uint;  /* "DAQ_SIZE" : Bytes pro DAQ-Liste*/
              uint;  /* "ODT_SIZE" : Bytes pro ODT*/
              uint;  /* "ODT_ENTRY_SIZE" : Bytes pro ODT_Entry*/
              uint;  /* "ODT_DAQ_BUFFER_FACTOR"  : Nutzbytes * Faktor = Bytes f?r Sendepuffer*/
              uint;  /* "ODT_STIM_BUFFER_FACTOR" : Nutzbytes * Faktor = Bytes f?r Empfangspuffer*/
              taggedstruct {
                block "BUFFER_RESERVE" struct {
                  uchar;  /* ODT_DAQ_BUFFER_ELEMENT_RESERVE  in % of ODT_DAQ_BUFFER_ELEMENT_SIZE */
                  uchar;  /* ODT_STIM_BUFFER_ELEMENT_RESERVE in % of ODT_STIM_BUFFER_ELEMENT_SIZE */
                };
              };
            };
            (block "DAQ_LIST" struct {
              uint;  /* DAQ_LIST_NUMBER  is in the range [0,1,..MIN_DAQ-1].*/
              taggedstruct {
                "DAQ_LIST_TYPE" enum {
                  "DAQ" = 1,
                  "STIM" = 2,
                  "DAQ_STIM" = 3
                };  /* DAQ: DIRECTION = DAQ only, STIM: DIRECTION = STIM only, DAQ_STIM: both directions are possible*/
                "MAX_ODT" uchar;  /*Number of ODTs in this DAQ list*/
                "MAX_ODT_ENTRIES" uchar;  /*Maximum number of entries in an ODT*/
                "FIRST_PID" uchar;  /*FIRST_PID: Is the PID in the DTO Packet of the first ODT transferred by this DAQ list.*/
                "EVENT_FIXED" uint;  /*The flag indicates that the Event Channel for this DAQ list can not be changed.*/
                block "PREDEFINED" taggedstruct {
                  (block "ODT" struct {
                    uchar;  /* ODT number*/
                    taggedstruct {
                      ("ODT_ENTRY" struct {
                        uchar;  /* ODT_ENTRY number*/
                        ulong;  /* address of element*/
                        uchar;  /* address extension of element*/
                        uchar;  /* size of element [AG]*/
                        uchar;  /* BIT_OFFSET*/
                      })*;
                    };
                  })*;
                };  /*PREDEFINED;The DAQ list is predefined and fixed in the slave devices memory.*/
              };
            })*;
            (block "EVENT" struct {
              char[101];  /* EVENT_CHANNEL_NAME*/
              char[9];  /* EVENT_CHANNEL_SHORT_NAME*/
              uint;  /* EVENT_CHANNEL_NUMBER*/
              enum {
                "DAQ" = 1,
                "STIM" = 2,
                "DAQ_STIM" = 3
              };  /* DAQ: only DAQ_LISTs with DIRECTION = DAQ, STIM: only DAQ_LISTs with DIRECTION = STIM, DAQ_STIM both kind of DAQ_LISTs*/
              uchar;  /* MAX_DAQ_LIST:Maximum number of DAQ lists in this event channel*/
              uchar;  /* TIME_CYCLE: Event channel time cycle*/
              uchar;  /* TIME_UNIT: Event channel time unit*/
              uchar;  /* PRIORITY:The event channel with event channel priority = FF has the highest priority*/
              taggedstruct {
                "COMPLEMENTARY_BYPASS_EVENT_CHANNEL_NUMBER" uint;  /*This keyword is used to make a combination of two event channels building a bypassing raster.*/
                "CONSISTENCY" enum {
                  "DAQ" = 0,
                  "EVENT" = 1
                };  /*With this keyword, the slave can indicate what kind of data consistency exists when data are processed within this Event.*/
                "EVENT_COUNTER_PRESENT" ;
                "RELATED_EVENT_CHANNEL_NUMBER" uint;
                "RELATED_EVENT_CHANNEL_NUMBER_FIXED" ;  /* RELATED_EVENT_CHANNEL_NUMBER can not be modified. */
                "DTO_CTR_DAQ_MODE" enum {
                  "INSERT_COUNTER" = 0,
                  "INSERT_STIM_COUNTER_COPY" = 1
                };
                "DTO_CTR_DAQ_MODE_FIXED" ;  /* DTO_CTR_DAQ_MODE properties can not be modified. */
                "DTO_CTR_STIM_MODE" enum {
                  "DO_NOT_CHECK_COUNTER" = 0,
                  "CHECK_COUNTER" = 1
                };
                "DTO_CTR_STIM_MODE_FIXED" ;  /* DTO_CTR_STIM_MODE properties can not be modified */
                "STIM_DTO_CTR_COPY_PRESENT" ;  /* DTO CTR can be saved for later reference */
                block "MIN_CYCLE_TIME" struct {
                  uchar;  /* EVENT_CHANNEL_TIME_CYCLE */
                  uchar;  /* EVENT_CHANNEL_TIME_UNIT  */
                };
                block "BUFFER_RESERVE_EVENT" struct {
                  uchar;  /* ODT_DAQ_BUFFER_ELEMENT_RESERVE  in % of ODT_DAQ_BUFFER_ELEMENT_SIZE */
                  uchar;  /* ODT_STIM_BUFFER_ELEMENT_RESERVE in % of ODT_STIM_BUFFER_ELEMENT_SIZE */
                };
                "CPU_LOAD_MAX" float;
                block "CPU_LOAD_CONSUMPTION_DAQ" struct {
                  float;  /* "DAQ_FACTOR"*/
                  float;  /* "ODT_FACTOR"*/
                  float;  /* "ODT_ENTRY_FACTOR"*/
                  taggedstruct {
                    (block "ODT_ENTRY_SIZE_FACTOR_TABLE" struct {
                      uint;  /*"SIZE"*/
                      float;  /* "SIZE_FACTOR"*/
                    })*;
                    block "CORE_LOAD_EP" struct {
                      uint;  /* CORE_NR: core reference number */
                      float;  /* CORE_LOAD_EP_MAX: max load of this event part */
                    };
                  };
                };
                block "CPU_LOAD_CONSUMPTION_STIM" struct {
                  float;  /* "DAQ_FACTOR"*/
                  float;  /* "ODT_FACTOR"*/
                  float;  /* "ODT_ENTRY_FACTOR"*/
                  taggedstruct {
                    (block "ODT_ENTRY_SIZE_FACTOR_TABLE" struct {
                      uint;  /*"SIZE"*/
                      float;  /*"SIZE_FACTOR"*/
                    })*;
                    block "CORE_LOAD_EP" struct {
                      uint;  /* CORE_NR: core reference number */
                      float;  /* CORE_LOAD_EP_MAX: max load of this event part */
                    };
                  };
                };
                block "CPU_LOAD_CONSUMPTION_QUEUE" struct {
                  float;  /* "ODT_FACTOR"*/
                  float;  /* "ODT_LENGTH_FACTOR",length in elements[AG]*/
                  taggedstruct {
                    block "CORE_LOAD_EP" struct {
                      uint;  /* CORE_NR: core reference number */
                      float;  /* CORE_LOAD_EP_MAX: max load of this event part */
                    };
                  };
                };
                block "CPU_LOAD_CONSUMPTION_QUEUE_STIM" struct {
                  float;  /* ODT_FACTOR */
                  float;  /* ODT_ELEMENT_LOAD: length in elements[AG] */
                  taggedstruct {
                    block "CORE_LOAD_EP" struct {
                      uint;  /* CORE_NR: core reference number */
                      float;  /* CORE_LOAD_EP_MAX: max load of this event part */
                    };
                  };
                };  /* overrules CPU_LOAD_CONSUMPTION_QUEUE for STIM QUEUE */
              };
            })*;
          };
        };

        taggedunion Daq_Event {
          "FIXED_EVENT_LIST" taggedstruct {
            ("EVENT" uint)*;
          };
          "VARIABLE" taggedstruct {
            block "AVAILABLE_EVENT_LIST" taggedstruct {
              ("EVENT" uint)*;
            };
            block "DEFAULT_EVENT_LIST" taggedstruct {
              ("EVENT" uint)*;
            };
          };
        };  /*This are characteristic for measurement objects*/

        struct Pag {
          uchar;  /* MAX_SEGMENTS: Is the total number of segments in the slave device*/
          taggedstruct {
            "FREEZE_SUPPORTED" ;  /*This flag indicates that all SEGMENTS can be put in FREEZE*/
          };
        };

        struct Pgm {
          enum {
            "PGM_MODE_ABSOLUTE" = 1,
            "PGM_MODE_FUNCTIONAL" = 2,
            "PGM_MODE_ABSOLUTE_AND_FUNCTIONAL" = 3
          };  /*The  ABSOLUTE_MODE  and  FUNCTIONAL_MODE  flags  indicate  the  clear/programming mode that can be used*/
          uchar;  /* MAX_SECTORS: Total number of available sectors*/
          uchar;  /* MAX_CTO_PGM: Maximum CTO size for PGM*/
          taggedstruct {
            (block "SECTOR" struct {
              char[101];  /* SECTOR_NAME*/
              uchar;  /* SECTOR_NUMBER*/
              ulong;  /* Start address for this SECTOR*/
              ulong;  /* Length of this SECTOR [AG]*/
              uchar;  /* CLEAR_SEQUENCE_NUMBER: The Clear Sequence Number describe, in which subsequential order the master has to clear and program flash memory sectors.*/
              uchar;  /* PROGRAM_SEQUENCE_NUMBER: The Program Sequence Number describe, in which subsequential order the master has to clear and program flash memory sectors.*/
              uchar;  /* PROGRAM_METHOD: The work flow depends on mode  absolute access or functional access*/
            })*;
            "COMMUNICATION_MODE_SUPPORTED" taggedunion {
              "BLOCK" taggedstruct {
                "SLAVE" ;  /*This flag indicates whether the Slave Block Mode is available during Programming.*/
                "MASTER" struct {
                  uchar;  /* MAX_BS_PGM:MAX_BS: indicates the maximum allowed block size as the number of consecutive command packets in a block sequence*/
                  uchar;  /* MIN_ST_PGM ndicates the required minimum separation time between the packets of a block transfer from the master device to the slave device in units of 100 ms*/
                };  /*This flag indicates whether the Master Block Mode is available*/
              };
              "INTERLEAVED" uchar;  /* QUEUE_SIZE_PGM: This value describe the total count of bytes for this queue*/
            };
          };
        };

        struct Segment {
          uchar;  /* SEGMENT_NUMBER: Logical data segment number*/
          uchar;  /* Total number of available pages*/
          uchar;  /* ADDRESS_EXTENSION: Address extension for this SEGMENT*/
          uchar;  /* COMPRESSION_METHOD: The COMPRESSION_x flags indicate which compression state of the incoming data the slave can process*/
          uchar;  /* ENCRYPTION_METHOD: The  ENCRYPTION_x flags indicate which encryption state of the incoming data the slave can process.*/
          taggedstruct {
            block "CHECKSUM" struct {
              enum {
                "XCP_ADD_11" = 1,
                "XCP_ADD_12" = 2,
                "XCP_ADD_14" = 3,
                "XCP_ADD_22" = 4,
                "XCP_ADD_24" = 5,
                "XCP_ADD_44" = 6,
                "XCP_CRC_16" = 7,
                "XCP_CRC_16_CITT" = 8,
                "XCP_CRC_32" = 9,
                "XCP_USER_DEFINED" = 255
              };  /* Checksum type*/
              taggedstruct {
                "MAX_BLOCK_SIZE" ulong;  /* Maximum block size for checksum calculation*/
                "EXTERNAL_FUNCTION" char[256];  /* Name of the Checksum.DLL*/
                "MTA_BLOCK_SIZE_ALIGN" uint;  /* required alignment of MTA and block size */
              };
            };
            (block "PAGE" struct {
              uchar;  /* PAGE_NUMBER: Logical page number*/
              enum {
                "ECU_ACCESS_NOT_ALLOWED" = 0,
                "ECU_ACCESS_WITHOUT_XCP_ONLY" = 1,
                "ECU_ACCESS_WITH_XCP_ONLY" = 2,
                "ECU_ACCESS_DONT_CARE" = 3
              };  /*The ECU_ACCESS_x  flags indicate whether and how the ECU can access this page.*/
              enum {
                "XCP_READ_ACCESS_NOT_ALLOWED" = 0,
                "XCP_READ_ACCESS_WITHOUT_ECU_ONLY" = 1,
                "XCP_READ_ACCESS_WITH_ECU_ONLY" = 2,
                "XCP_READ_ACCESS_DONT_CARE" = 3
              };  /*The XCP_x_ACCESS_y flags indicate whether and how the XCP master can access this page.*/
              enum {
                "XCP_WRITE_ACCESS_NOT_ALLOWED" = 0,
                "XCP_WRITE_ACCESS_WITHOUT_ECU_ONLY" = 1,
                "XCP_WRITE_ACCESS_WITH_ECU_ONLY" = 2,
                "XCP_WRITE_ACCESS_DONT_CARE" = 3
              };  /*The XCP_WRITE_ACCESS_x flags indicate whether the  X CP master can write to this PAGE*/
              taggedstruct {
                "INIT_SEGMENT" uchar;  /* references segment that initialises this page*/
              };
            })*;  /* PAGES for this SEGMENT*/
            (block "ADDRESS_MAPPING" struct {
              ulong;  /* source address*/
              ulong;  /* destination address*/
              ulong;  /* length*/
            })*;
            "PGM_VERIFY" ulong;  /* verification value for PGM*/
          };
        };  /*Settings for MEMORY_SEGMENT*/

        taggedstruct Time_Correlation {
          "DAQ_TIMESTAMPS_RELATE_TO" enum {
            "XCP_SLAVE_CLOCK" = 0,
            "ECU_CLOCK" = 1
          };
          (block "CLOCK" struct {
            char;  /* globally unique clock identifier (UUID/EUI), 1st octet (most significant byte)*/
            char;  /* globally unique clock identifier (UUID/EUI), 2nd octet */
            char;  /* globally unique clock identifier (UUID/EUI), 3rd octet */
            char;  /* globally unique clock identifier (UUID/EUI), 4th octet */
            char;  /* globally unique clock identifier (UUID/EUI), 5th octet */
            char;  /* globally unique clock identifier (UUID/EUI), 6th octet */
            char;  /* globally unique clock identifier (UUID/EUI), 7th octet */
            char;  /* globally unique clock identifier (UUID/EUI), 8th octet (least significant byte)*/
            enum {
              "XCP_SLAVE_CLOCK" = 0,
              "ECU_CLOCK" = 1,
              "XCP_SLAVE_GRANDMASTER_CLOCK" = 2,
              "ECU_GRANDMASTER_CLOCK" = 3
            };  /* clock enumerator */
            enum {
              "RANDOMLY_READABLE" = 0,
              "LIMITED_READABLE" = 1,
              "NOT_READABLE" = 2
            };  /* readability */
            enum {
              "SYN_UNSUPPORTED" = 0,
              "SYNCHRONIZATION_ONLY" = 1,
              "SYNTONIZATION_ONLY" = 2,
              "SYN_ALL" = 3
            };
            uchar;  /* clock quality, stratum level */
            taggedstruct {
              block "TIMESTAMP_CHARACTERIZATION" struct {
                uint;  /* TIMESTAMP_TICKS */
                enum {
                  "UNIT_1NS" = 0,
                  "UNIT_10NS" = 1,
                  "UNIT_100NS" = 2,
                  "UNIT_1US" = 3,
                  "UNIT_10US" = 4,
                  "UNIT_100US" = 5,
                  "UNIT_1MS" = 6,
                  "UNIT_10MS" = 7,
                  "UNIT_100MS" = 8,
                  "UNIT_1S" = 9,
                  "UNIT_1PS" = 10,
                  "UNIT_10PS" = 11,
                  "UNIT_100PS" = 12
                };  /* RESOLUTION OF TIMESTAMP */
                enum {
                  "SIZE_FOUR_BYTE" = 4,
                  "SIZE_EIGHT_BYTE" = 8
                };  /* NATIVE TIMESTAMP SIZE */
              };
            };
            uint64;  /* MAX_TIMESTAMP_VALUE_BEFORE_WRAP_AROUND */
            enum {
              "ATOMIC_TIME" = 0,
              "UNIVERSAL_COORDINATED_TIME" = 1,
              "ARBITRARY" = 2
            };
          })*;
        };

        taggedstruct Common_Parameters {
          block "PROTOCOL_LAYER" struct Protocol_Layer;
          block "TIME_CORRELATION" taggedstruct Time_Correlation;
          block "SEGMENT" struct Segment;
          block "DAQ" struct Daq;
          block "PAG" struct Pag;
          block "PGM" struct Pgm;
          block "DAQ_EVENT" taggedunion Daq_Event;
        };

        struct CAN_Parameters {
          uint;  /* XCP on CAN version, currently 0x0103*/
          taggedstruct {
            "CAN_ID_BROADCAST" ulong;  /* Auto-detection CAN-ID*/
            "CAN_ID_MASTER" ulong;  /* CMD/STIM CAN-ID*/
            "CAN_ID_MASTER_INCREMENTAL" ;  /* Master uses range of CAN-IDs. Start of range = CAN_ID_MASTER*/
            "CAN_ID_SLAVE" ulong;  /* RES/ERR/EV/SERV/DAQ CAN-ID*/
            "CAN_ID_GET_DAQ_CLOCK_MULTICAST" ulong;  /* Only to be used for GET_DAQ_CLOCK_MULTICAST*/
            "BAUDRATE" ulong;  /* Baudrate in Hz*/
            "SAMPLE_POINT" uchar;  /* Sample point in % of bit time*/
            "SAMPLE_RATE" enum {
              "SINGLE" = 1,
              "TRIPLE" = 3
            };  /* Sample per bit*/
            "BTL_CYCLES" uchar;  /* slots per bit time*/
            "SJW" uchar;  /*Length synchr. segment*/
            "SYNC_EDGE" enum {
              "SINGLE" = 1,
              "DUAL" = 2
            };  /* SINGLE: on falling edge only
DUAL: on falling and rising edge*/
            "MAX_DLC_REQUIRED" ;  /* master to slave frames always to have DLC = MAX_DLC = 8*/
            (block "DAQ_LIST_CAN_ID" struct {
              uint;  /* reference to DAQ_LIST_NUMBER*/
              taggedstruct {
                "VARIABLE" ;
                "FIXED" ulong;  /* this DAQ_LIST always on this CAN_ID*/
              };  /* exclusive tags: either VARIABLE or FIXED*/
            })*;
            (block "EVENT_CAN_ID_LIST" struct {
              uint;  /* reference to EVENT_NUMBER*/
              taggedstruct {
                ("FIXED" ulong)*;  /* this Event always on this IDs*/
              };
            })*;
            "MAX_BUS_LOAD" ulong;  /* maximum available bus in bit/s*/
            block "CAN_FD" struct {
              taggedstruct {
                "MAX_DLC" uint;  /* 8, 12, 16, 20, 24, 32, 48 or 64*/
                "CAN_FD_DATA_TRANSFER_BAUDRATE" ulong;  /* BAUDRATE [Hz]*/
                "SAMPLE_POINT" uchar;  /* sample point receiver [% complete bit time]*/
                "BTL_CYCLES" uchar;  /* BTL_CYCLES [slots per bit time]*/
                "SJW" uchar;  /* length synchr. segment [BTL_CYCLES]*/
                "SYNC_EDGE" enum {
                  "SINGLE" = 1,
                  "DUAL" = 2
                };
                "MAX_DLC_REQUIRED" ;  /* master to slave frames always to have DLC = MAX_DLC_for CAN-FD*/
                "SECONDARY_SAMPLE_POINT" uchar;  /* sender sample point [% complete bit time]*/
                "TRANSCEIVER_DELAY_COMPENSATION" enum {
                  "OFF" = 0,
                  "ON" = 1
                };
              };
            };
          };
          taggedstruct {
            ("OPTIONAL_TL_SUBCMD" enum {
              "GET_SLAVE_ID" = 255,
              "GET_DAQ_ID" = 254,
              "SET_DAQ_ID" = 253,
              "GET_DAQ_CLOCK_MULTICAST" = 250
            })*;
          };
        };

        struct SxI_Parameters {
          uint;  /* XCP on SxI version, currently 0x0103*/
          ulong;  /* BAUDRATE [Hz]*/
          taggedstruct {
            "ASYNCH_FULL_DUPLEX_MODE" struct {
              enum {
                "PARITY_NONE" = 0,
                "PARITY_ODD" = 1,
                "PARITY_EVEN" = 2
              };  /* Parity bit settings*/
              enum {
                "ONE_STOP_BIT" = 1,
                "TWO_STOP_BITS" = 2
              };  /*Stop bit settings*/
              taggedstruct {
                block "FRAMING" struct {
                  uchar;  /* SYNC character*/
                  uchar;  /* ESC character*/
                };
              };  /* Support for framing mechanism*/
            };
            "SYNCH_FULL_DUPLEX_MODE_BYTE" ;
            "SYNCH_FULL_DUPLEX_MODE_WORD" ;
            "SYNCH_FULL_DUPLEX_MODE_DWORD" ;
            "SYNCH_MASTER_SLAVE_MODE_BYTE" ;
            "SYNCH_MASTER_SLAVE_MODE_WORD" ;
            "SYNCH_MASTER_SLAVE_MODE_DWORD" ;
          };  /* exclusive tags*/
          enum {
            "HEADER_LEN_BYTE" = 0,
            "HEADER_LEN_CTR_BYTE" = 1,
            "HEADER_LEN_FILL_BYTE" = 2,
            "HEADER_LEN_WORD" = 3,
            "HEADER_LEN_CTR_WORD" = 4,
            "HEADER_LEN_FILL_WORD" = 5
          };  /* XCP packet header*/
          enum {
            "NO_CHECKSUM" = 0,
            "CHECKSUM_BYTE" = 1,
            "CHECKSUM_WORD" = 2
          };  /* Checksum type*/
        };

        struct TCP_IP_Parameters {
          uint;  /* XCP on TCP_IP version, currently 0x0103 */
          uint;  /* PORT */
          taggedunion {
            "HOST_NAME" char[256];  /*Name of the host like localhost*/
            "ADDRESS" char[15];  /* IP address like 127.0.0.1*/
            "IPV6" char[39];
          };
          taggedstruct {
            "MAX_BUS_LOAD" ulong;  /* maximum available bus load in percent */
            "MAX_BIT_RATE" ulong;  /* Network speed which is the base for MAX_BUS_LOAD in Mbit*/
          };
          taggedstruct {
            ("OPTIONAL_TL_SUBCMD" enum {
              "GET_SLAVE_ID" = 255,
              "GET_DAQ_CLOCK_MULTICAST" = 250
            })*;  /* XCP-Code of optional transport layer */
          };
        };

        struct UDP_IP_Parameters {
          uint;  /* XCP on UDP version, currently 0x0103 */
          uint;  /* PORT */
          taggedunion {
            "HOST_NAME" char[256];  /*Name of the host like localhost*/
            "ADDRESS" char[15];  /* IP address like 127.0.0.1*/
            "IPV6" char[39];
          };
          taggedstruct {
            "MAX_BUS_LOAD" ulong;  /* maximum available bus load in percent */
            "MAX_BIT_RATE" ulong;  /* Network speed which is the base for MAX_BUS_LOAD in Mbit*/
          };
          taggedstruct {
            ("OPTIONAL_TL_SUBCMD" enum {
              "GET_SLAVE_ID" = 255,
              "GET_DAQ_CLOCK_MULTICAST" = 250
            })*;  /* XCP-Code of optional transport layer */
          };
        };

        struct ep_parameters {
          uchar;  /* ENDPOINT_NUMBER, not endpoint address */
          enum {
            "BULK_TRANSFER" = 2,
            "INTERRUPT_TRANSFER" = 3
          };
          uint;  /* wMaxPacketSize: Maximum packet  size of endpoint in bytes */
          uchar;  /* bInterval: polling of endpoint  */
          enum {
            "MESSAGE_PACKING_SINGLE" = 0,
            "MESSAGE_PACKING_MULTIPLE" = 1,
            "MESSAGE_PACKING_STREAMING" = 2
          };  /* Packing of XCP Messages, SINGLE: Single per USB data packet, MULTIPLE: Multiple per USB data packet, STREAMING: No restriction by packet sizes*/
          enum {
            "ALIGNMENT_8_BIT" = 0,
            "ALIGNMENT_16_BIT" = 1,
            "ALIGNMENT_32_BIT" = 2,
            "ALIGNMENT_64_BIT" = 3
          };  /* Alignment mandatory for all packing types*/
          taggedstruct {
            "RECOMMENDED_HOST_BUFSIZE" uint;  /* Recommended size for the host buffer size. The size is defined as multiple of wMaxPacketSize.  */
          };
        };

        struct USB_Parameters {
          uint;  /* XCP on USB version e.g. 1.3 = 0x0103 */
          uint;  /* Vendor ID                       */
          uint;  /* Product ID                      */
          uchar;  /* Number of interface             */
          enum {
            "HEADER_LEN_BYTE" = 0,
            "HEADER_LEN_CTR_BYTE" = 1,
            "HEADER_LEN_FILL_BYTE" = 2,
            "HEADER_LEN_WORD" = 3,
            "HEADER_LEN_CTR_WORD" = 4,
            "HEADER_LEN_FILL_WORD" = 5
          };  /* XCP packet header*/
          taggedunion {
            block "OUT_EP_CMD_STIM" struct ep_parameters;  /* OUT-EP for CMD and STIM (if not specified otherwise)*/
          };
          taggedunion {
            block "IN_EP_RESERR_DAQ_EVSERV" struct ep_parameters;  /* IN-EP for RES/ERR, DAQ (if not specified otherwise) and EV/SERV (if not specified otherwise)  */
          };
          taggedstruct {
            "ALTERNATE_SETTING_NO" uchar;  /* Number of alternate setting   */
            "INTERFACE_STRING_DESCRIPTOR" char[101];  /* String Descriptor of XCP interface*/
            (block "OUT_EP_ONLY_STIM" struct ep_parameters)*;  /* multiple OUT-EP's for STIM*/
            (block "IN_EP_ONLY_DAQ" struct ep_parameters)*;  /* multiple IN-EP's for DAQ*/
            block "IN_EP_ONLY_EVSERV" struct ep_parameters;  /* only one IN-EP for EV/SERV*/
            (block "DAQ_LIST_USB_ENDPOINT" struct {
              uint;  /* reference to DAQ_LIST_NUMBER */
              taggedstruct {
                "FIXED_IN" uchar;  /* this DAQ list always ENDPOINT_NUMBER, not endpoint address */
                "FIXED_OUT" uchar;  /* this STIM list always ENDPOINT_NUMBER, not endpoint address */
              };
            })*;
          };
          taggedstruct {
            ("OPTIONAL_TL_SUBCMD" enum {
              "GET_DAQ_EP" = 255,
              "SET_DAQ_EP" = 254
            })*;  /* XCP-Code of optional transport layer */
          };  /* end of optional */
        };

        enum packet_assignment_type {
          "NOT_ALLOWED" = 0,
          "FIXED" = 1,
          "VARIABLE_INITIALISED" = 2,
          "VARIABLE" = 3
        };

        struct buffer {
          uchar;  /* Buffer number*/
          taggedstruct {
            "MAX_FLX_LEN_BUF" taggedunion {
              "FIXED" uchar;  /* constant value, can't be modified on runtime*/
              "VARIABLE" uchar;  /* initial value, can be modified on runtime*/
            };  /* maximal size of the buffer [byte]*/
            block "LPDU_ID" taggedstruct {
              "FLX_SLOT_ID" taggedunion {
                "FIXED" uint;  /* constant value, can't be modified on runtime*/
                "VARIABLE" taggedstruct {
                  "INITIAL_VALUE" uint;
                };  /* initial value, can be modified on runtime*/
              };  /* FlexRay timing, slot id*/
              "OFFSET" taggedunion {
                "FIXED" uchar;  /* constant value, can't be modified on runtime*/
                "VARIABLE" taggedstruct {
                  "INITIAL_VALUE" uchar;
                };  /* initial value, can be modified on runtime*/
              };  /* FlexRay timing, base cycle*/
              "CYCLE_REPETITION" taggedunion {
                "FIXED" uchar;  /* constant value, can't be modified on runtime*/
                "VARIABLE" taggedstruct {
                  "INITIAL_VALUE" uchar;
                };  /* initial value, can be modified on runtime*/
              };  /* FlexRay timing, cycle repetition*/
              "CHANNEL" taggedunion {
                "FIXED" enum {
                  "A" = 0,
                  "B" = 1
                };  /* constant value, can't be modified on runtime*/
                "VARIABLE" taggedstruct {
                  "INITIAL_VALUE" enum {
                    "A" = 0,
                    "B" = 1
                  };
                };  /* initial value, can be modified on runtime*/
              };  /* FlexRay Channel A or B*/
            };  /* LPDU-ID,  Data  Link  Layer  Protocol  Data  Unit  Identifier*/
            block "XCP_PACKET" taggedstruct {
              "CMD" enum packet_assignment_type;
              "RES_ERR" enum packet_assignment_type;
              "EV_SERV" enum packet_assignment_type;
              "DAQ" enum packet_assignment_type;
              "STIM" enum packet_assignment_type;
              "MULTICAST" enum packet_assignment_type;
            };  /* XCP packet type*/
          };
        };

        struct FLX_Parameters {
          uint;  /* XCP on FlexRay version e.g. "1.3" = 0x0103*/
          uint;  /* T1_FLX [ms] Time-out while waiting for an XCP on FlexRay response e.g. FLX_ASSIGN*/
          char[256];  /* FIBEX-file with extension and without path, including CHI information*/
          char[256];  /* cluster-ID, id attribute of the FIBEX cluster*/
          uchar;  /* NAX, node address of the ECU*/
          enum {
            "HEADER_NAX" = 0,
            "HEADER_NAX_FILL" = 1,
            "HEADER_NAX_CTR" = 2,
            "HEADER_NAX_FILL3" = 3,
            "HEADER_NAX_CTR_FILL2" = 4,
            "HEADER_NAX_LEN" = 5,
            "HEADER_NAX_CTR_LEN" = 6,
            "HEADER_NAX_FILL2_LEN" = 7,
            "HEADER_NAX_CTR_FILL_LEN" = 8
          };  /* header type of the XCP on FlexRay message*/
          enum {
            "PACKET_ALIGNMENT_8" = 0,
            "PACKET_ALIGNMENT_16" = 1,
            "PACKET_ALIGNMENT_32" = 2
          };  /* XCP packet alignment within the XCP on FlexRay Message*/
          taggedunion {
            block "INITIAL_CMD_BUFFER" struct buffer;
          };  /* XCP dedicated buffer used to transmit XCP commands*/
          taggedunion {
            block "INITIAL_RES_ERR_BUFFER" struct buffer;
          };  /* XCP dedicated buffer used to receive the responses on the XCP commands*/
          taggedstruct {
            (block "POOL_BUFFER" struct buffer)*;
          };  /* XCP dedicated buffer(s) used for XCP-DAQ, -STIM and -EV/SERV*/
          taggedstruct {
            ("OPTIONAL_TL_SUBCMD" enum {
              "FLX_ASSIGN" = 255,
              "FLX_ACTIVATE" = 254,
              "FLX_DEACTIVATE" = 253,
              "GET_DAQ_FLX_BUF" = 252,
              "SET_DAQ_FLX_BUF" = 251,
              "GET_DAQ_CLOCK_MULTICAST" = 250
            })*;
          };  /* XCP-Code of optional transport layer specific subcommand supported by the slave*/
        };
      block "IF_DATA" taggedunion {
        "CANAPE_EXT" struct {
          int;  /* version number */
          taggedstruct {
            "LINK_MAP" struct {
              char[256];  /* segment name */
              long;  /* base address of the segment */
              uint;  /* address extension of the segment */
              uint;  /* flag: address is relative to DS */
              long;  /* offset of the segment address */
              uint;  /* datatypValid */
              uint;  /* enum datatyp */
              uint;  /* bit offset of the segment */
            };
            "DISPLAY" struct {
              long;  /* display color */
              double;  /* minimal display value (phys)*/
              double;  /* maximal display value (phys)*/
            };
            "VIRTUAL_CONVERSION" struct {
              char[256];  /* name of the conversion formula */
            };
          };
        };
        "CANAPE_MODULE" struct {
          taggedstruct {
            ("RECORD_LAYOUT_STEPSIZE" struct {
              char[256];  /* name of record layout*/
              uint;  /* stepsize for FNC_VALUES */
              uint;  /* stepsize for AXIS_PTS_X */
              uint;  /* stepsize for AXIS_PTS_Y */
              uint;  /* stepsize for AXIS_PTS_Z */
              uint;  /* stepsize for AXIS_PTS_4 */
              uint;  /* stepsize for AXIS_PTS_5 */
            })*;
          };
        };
        "CANAPE_ADDRESS_UPDATE" taggedstruct {
          ("EPK_ADDRESS" struct {
            char[1024];  /* name of the corresponding symbol in MAP file */
            long;  /* optional address offset */
          })*;
          "ECU_CALIBRATION_OFFSET" struct {
            char[1024];  /* name of the corresponding symbol in MAP file */
            long;  /* optional address offset */
          };
          (block "CALIBRATION_METHOD" taggedunion {
            "AUTOSAR_SINGLE_POINTERED" struct {
              char[1024];  /* MAP symbol name for pointer table in RAM */
              long;  /* optional address offset */
              taggedstruct {
                "ORIGINAL_POINTER_TABLE" struct {
                  char[1024];  /* MAP symbol name for pointer table in FLASH */
                  long;  /* optional address offset */
                };
              };
            };
            "InCircuit2" struct {
              char[1024];  /* MAP symbol name for pointer table in RAM */
              long;  /* optional address offset */
              taggedstruct {
                "ORIGINAL_POINTER_TABLE" struct {
                  char[1024];  /* MAP symbol name for pointer table in FLASH */
                  long;  /* optional address offset */
                };
                "FLASH_SECTION" struct {
                  ulong;  /* start address of flash section */
                  ulong;  /* length of flash section */
                };
              };
            };
          })*;
          block "MAP_SYMBOL" taggedstruct {
            "FIRST" struct {
              char[1024];  /* symbol name of the corresponding segment in MAP file */
              long;  /* offset */
            };
            "LAST" struct {
              char[1024];  /* symbol name of the corresponding segment in MAP file */
              long;  /* offset */
            };
            ("ADDRESS_MAPPING_XCP" struct {
              char[1024];  /* symbol name of source range in MAP file */
              char[1024];  /* symbol name of destination range in MAP file */
            })*;
          };
          (block "MEMORY_SEGMENT" struct {
            char[1024];  /* name of the memory segment */
            taggedstruct {
              "FIRST" struct {
                char[1024];  /* symbol name of the corresponding segment in MAP file */
                long;  /* offset */
              };
              "LAST" struct {
                char[1024];  /* symbol name of the corresponding segment in MAP file */
                long;  /* offset */
              };
              ("ADDRESS_MAPPING_XCP" struct {
                char[1024];  /* symbol name of source range in MAP file */
                char[1024];  /* symbol name of destination range in MAP file */
              })*;
            };
          })*;
        };
        "CANAPE_GROUP" taggedstruct {
          block "STRUCTURE_LIST" (char[1024])*;
        };
        "XCP" struct {
          taggedstruct Common_Parameters;  /* default parameters */
          taggedstruct {
            block "XCP_ON_CAN" struct {
              struct CAN_Parameters;  /* specific for CAN */
              taggedstruct Common_Parameters;  /* overruling of default */
            };
            block "XCP_ON_SxI" struct {
              struct SxI_Parameters;  /* specific for SxI */
              taggedstruct Common_Parameters;  /* overruling of default */
            };
            block "XCP_ON_TCP_IP" struct {
              struct TCP_IP_Parameters;  /* specific for TCP_IP */
              taggedstruct Common_Parameters;  /* overruling of default */
            };
            block "XCP_ON_UDP_IP" struct {
              struct UDP_IP_Parameters;  /* specific for UDP */
              taggedstruct Common_Parameters;  /* overruling of default */
            };
            block "XCP_ON_USB" struct {
              struct USB_Parameters;  /* specific for USB      */
              taggedstruct Common_Parameters;  /* overruling of default */
            };
            block "XCP_ON_FLX" struct {
              struct FLX_Parameters;  /* specific for FlexRay  */
              taggedstruct Common_Parameters;  /* overruling of default */
            };
          };  /* transport layer parameters*/
        };
        "XCPplus" struct {
          uint;  /* XCP plus AML structure version */
          taggedstruct Common_Parameters;  /* default parameters */
          taggedstruct {
            (block "XCP_ON_CAN" struct {
              struct CAN_Parameters;  /* specific for CAN */
              taggedstruct Common_Parameters;  /* overruling of default */
              taggedstruct {
                "TRANSPORT_LAYER_INSTANCE" char[101];  /* name of the transport layer instance */
              };
            })*;
            (block "XCP_ON_SxI" struct {
              struct SxI_Parameters;  /* specific for SxI */
              taggedstruct Common_Parameters;  /* overruling of default */
              taggedstruct {
                "TRANSPORT_LAYER_INSTANCE" char[101];  /* name of the transport layer instance */
              };
            })*;
            (block "XCP_ON_TCP_IP" struct {
              struct TCP_IP_Parameters;  /* specific for TCP_IP */
              taggedstruct Common_Parameters;  /* overruling of default */
              taggedstruct {
                "TRANSPORT_LAYER_INSTANCE" char[101];  /* name of the transport layer instance */
              };
            })*;
            (block "XCP_ON_UDP_IP" struct {
              struct UDP_IP_Parameters;  /* specific for UDP */
              taggedstruct Common_Parameters;  /* overruling of default */
              taggedstruct {
                "TRANSPORT_LAYER_INSTANCE" char[101];  /* name of the transport layer instance */
              };
            })*;
            (block "XCP_ON_USB" struct {
              struct USB_Parameters;  /* specific for USB */
              taggedstruct Common_Parameters;  /* overruling of default */
              taggedstruct {
                "TRANSPORT_LAYER_INSTANCE" char[101];  /* name of the transport layer instance */
              };
            })*;
            (block "XCP_ON_FLX" struct {
              struct FLX_Parameters;  /* specific for FlexRay */
              taggedstruct Common_Parameters;  /* overruling of default */
              taggedstruct {
                "TRANSPORT_LAYER_INSTANCE" char[101];  /* name of the transport layer instance */
              };
            })*;
          };  /* transport layer specific parameters */
        };
      };
    /end A2ML

    /begin MOD_PAR ""
      /begin MEMORY_SEGMENT
        CALRAM "" VARIABLES RAM INTERN 0x25014 0xDF -1 -1 -1 -1 -1
        /begin IF_DATA XCP
          /begin SEGMENT
            0xFF
            0x01
            0x00
            0x00
            0x00
            /begin PAGE
              0x00
              ECU_ACCESS_DONT_CARE
              XCP_READ_ACCESS_DONT_CARE
              XCP_WRITE_ACCESS_DONT_CARE
              INIT_SEGMENT 0x00
            /end PAGE
            /begin ADDRESS_MAPPING
              0x025014
              0x025014
              0xDF
            /end ADDRESS_MAPPING
            /begin ADDRESS_MAPPING
              0x025014
              0x00
              0xDF
            /end ADDRESS_MAPPING
          /end SEGMENT
        /end IF_DATA
      /end MEMORY_SEGMENT
    /end MOD_PAR

    /begin MOD_COMMON ""
      BYTE_ORDER MSB_LAST
      ALIGNMENT_BYTE 1
      ALIGNMENT_WORD 1
      ALIGNMENT_LONG 1
      ALIGNMENT_FLOAT16_IEEE 1
      ALIGNMENT_FLOAT32_IEEE 1
      ALIGNMENT_FLOAT64_IEEE 1
      ALIGNMENT_INT64 1
    /end MOD_COMMON

    /begin IF_DATA CANAPE_ADDRESS_UPDATE
    /end IF_DATA

    /begin IF_DATA XCP
      /begin PROTOCOL_LAYER
        0x0103
        0x03E8
        0x2710
        0x00
        0x00
        0x00
        0x00
        0x00
        0xFA
        0x0574
        BYTE_ORDER_MSB_LAST
        ADDRESS_GRANULARITY_BYTE
        OPTIONAL_CMD ALLOC_ODT_ENTRY
        OPTIONAL_CMD ALLOC_ODT
        OPTIONAL_CMD ALLOC_DAQ
        OPTIONAL_CMD FREE_DAQ
        OPTIONAL_CMD GET_DAQ_RESOLUTION_INFO
        OPTIONAL_CMD GET_DAQ_PROCESSOR_INFO
        OPTIONAL_CMD GET_DAQ_CLOCK
        OPTIONAL_CMD START_STOP_SYNCH
        OPTIONAL_CMD START_STOP_DAQ_LIST
        OPTIONAL_CMD GET_DAQ_LIST_MODE
        OPTIONAL_CMD SET_DAQ_LIST_MODE
        OPTIONAL_CMD WRITE_DAQ
        OPTIONAL_CMD SET_DAQ_PTR
        OPTIONAL_CMD CLEAR_DAQ_LIST
        OPTIONAL_CMD DOWNLOAD
        OPTIONAL_CMD UPLOAD
        OPTIONAL_CMD SET_MTA
        OPTIONAL_CMD GET_COMM_MODE_INFO
      /end PROTOCOL_LAYER
      /begin DAQ
        DYNAMIC
        0x00
        0x03
        0x00
        OPTIMISATION_TYPE_DEFAULT
        ADDRESS_EXTENSION_FREE
        IDENTIFICATION_FIELD_TYPE_RELATIVE_BYTE
        GRANULARITY_ODT_ENTRY_SIZE_DAQ_BYTE
        0xF8
        OVERLOAD_INDICATION_PID
        /begin TIMESTAMP_SUPPORTED
          0x01
          SIZE_DWORD
          UNIT_1US
          TIMESTAMP_FIXED
        /end TIMESTAMP_SUPPORTED
        /begin EVENT
          "Event1"
          "Event1"
          0x01
          DAQ
          0xFF
          0x01
          0x06
          0x00
        /end EVENT
        /begin EVENT
          "Event2"
          "Event2"
          0x02
          DAQ
          0xFF
          0x01
          0x06
          0x00
        /end EVENT
        /begin EVENT
          "Event3"
          "Event3"
          0x03
          DAQ
          0xFF
          0x01
          0x06
          0x00
        /end EVENT
      /end DAQ
      /begin PAG
        0x01
      /end PAG
      /begin PGM
        PGM_MODE_ABSOLUTE
        0x00
        0x00
      /end PGM
      /begin XCP_ON_TCP_IP
        0x0100
        0x15B3
        ADDRESS "127.0.0.1"
      /end XCP_ON_TCP_IP
      /begin XCP_ON_UDP_IP
        0x0100
        0x15B3
        ADDRESS "172.31.31.195"
      /end XCP_ON_UDP_IP
    /end IF_DATA

    /begin TYPEDEF_MEASUREMENT Measurement_UByte ""
      UBYTE NO_COMPU_METHOD 0 0 0 255
    /end TYPEDEF_MEASUREMENT

    /begin TYPEDEF_MEASUREMENT Measurement_ULong ""
      ULONG NO_COMPU_METHOD 0 0 0 4294967295
    /end TYPEDEF_MEASUREMENT

    /begin TYPEDEF_MEASUREMENT Measurement_UWord ""
      UWORD NO_COMPU_METHOD 0 0 0 65535
    /end TYPEDEF_MEASUREMENT

    /begin TYPEDEF_STRUCTURE ecu ""
      0xC
      SYMBOL_TYPE_LINK "ecu"
      /begin STRUCTURE_COMPONENT
        counter Measurement_UWord
        0
        SYMBOL_TYPE_LINK "counter"
      /end STRUCTURE_COMPONENT
      /begin STRUCTURE_COMPONENT
        byte Measurement_UByte
        2
        SYMBOL_TYPE_LINK "byte"
      /end STRUCTURE_COMPONENT
      /begin STRUCTURE_COMPONENT
        word Measurement_UWord
        4
        SYMBOL_TYPE_LINK "word"
      /end STRUCTURE_COMPONENT
      /begin STRUCTURE_COMPONENT
        dword Measurement_ULong
        8
        SYMBOL_TYPE_LINK "dword"
      /end STRUCTURE_COMPONENT
    /end TYPEDEF_STRUCTURE

    /begin MEASUREMENT PWM "Pulse width signal from PWM_level and Triangle"
      UBYTE HighLow 0 0 0 255
      BYTE_ORDER MSB_LAST
      ECU_ADDRESS 0x32D86
      ECU_ADDRESS_EXTENSION 0x0
      FORMAT "%.0"
      SYMBOL_LINK "bytePWM" 0
      /begin IF_DATA CANAPE_EXT
        100
        LINK_MAP "bytePWM" 0x32D86 0 0 0 1 0x87 0
        DISPLAY 0x0 0 100
      /end IF_DATA
    /end MEASUREMENT

    /begin MEASUREMENT PWMFiltered "Low pass filtered PWM signal"
      UBYTE BitSlice.CONVERSION 0 0 0 255
      BYTE_ORDER MSB_LAST
      ECU_ADDRESS 0x3430D
      ECU_ADDRESS_EXTENSION 0x0
      FORMAT "%.3"
      SYMBOL_LINK "bytePWMFiltered" 0
      /begin IF_DATA CANAPE_EXT
        100
        LINK_MAP "bytePWMFiltered" 0x3430D 0 0 0 1 0x87 0
        DISPLAY 0x0 0 100
      /end IF_DATA
    /end MEASUREMENT

    /begin MEASUREMENT PWM_Level ""
      SBYTE BitSlice.CONVERSION 0 0 -50 50
      BYTE_ORDER MSB_LAST
      ECU_ADDRESS 0x251C0
      ECU_ADDRESS_EXTENSION 0x0
      FORMAT "%.0"
      READ_WRITE
      SYMBOL_LINK "sbytePWMLevel" 0
      /begin IF_DATA CANAPE_EXT
        100
        LINK_MAP "sbytePWMLevel" 0x251C0 0 0 0 1 0xC7 0
        DISPLAY 0x0 -50 50
      /end IF_DATA
    /end MEASUREMENT

    /begin MEASUREMENT Triangle "Triangle test signal used for PWM output PWM"
      SBYTE BitSlice.CONVERSION 0 0 -50 50
      BYTE_ORDER MSB_LAST
      ECU_ADDRESS 0x30D12
      ECU_ADDRESS_EXTENSION 0x0
      FORMAT "%.3"
      SYMBOL_LINK "sbyteTriangle" 0
      /begin IF_DATA CANAPE_EXT
        100
        LINK_MAP "sbyteTriangle" 0x30D12 0 0 0 1 0xC7 0
        DISPLAY 0x0 -50 50
      /end IF_DATA
    /end MEASUREMENT

    /begin CHARACTERISTIC a0 "Digital Filter v=(vin*a0+v*b0)/c0"
      VALUE 0x25018 __UWord_Value 0 DigitalFilterConversion 0 1
      BYTE_ORDER MSB_LAST
      ECU_ADDRESS_EXTENSION 0x0
      EXTENDED_LIMITS 0 1
      FORMAT "%.3"
      SYMBOL_LINK "a" 0
      /begin IF_DATA CANAPE_EXT
        100
        LINK_MAP "a" 0x25018 0 0 0 1 0x8F 0
        DISPLAY 0x0 0 1
      /end IF_DATA
    /end CHARACTERISTIC

    /begin MEASUREMENT ampl "Amplitude of channel 1-3 "
      FLOAT32_IEEE NO_COMPU_METHOD 0 0 0 200
      BYTE_ORDER MSB_LAST
      ECU_ADDRESS 0x2500C
      ECU_ADDRESS_EXTENSION 0x0
      FORMAT "%.3"
      READ_WRITE
      SYMBOL_LINK "ampl" 0
      /begin IF_DATA CANAPE_EXT
        100
        LINK_MAP "ampl" 0x2500C 0 0 0 1 0x1 0
        DISPLAY 0x0 0 200
      /end IF_DATA
    /end MEASUREMENT

    /begin CHARACTERISTIC b0 "Digital Filter v=(vin*a0+v*b0)/c0"
      VALUE 0x2501A __UWord_Value 0 DigitalFilterConversion 0 1
      BYTE_ORDER MSB_LAST
      ECU_ADDRESS_EXTENSION 0x0
      EXTENDED_LIMITS 0 1
      FORMAT "%.3"
      SYMBOL_LINK "b" 0
      /begin IF_DATA CANAPE_EXT
        100
        LINK_MAP "b" 0x2501A 0 0 0 1 0x8F 0
        DISPLAY 0x0 0 1
      /end IF_DATA
    /end CHARACTERISTIC

    /begin MEASUREMENT byte1 "Demo, read and write possible"
      UBYTE NO_COMPU_METHOD 0 0 0 255
      BYTE_ORDER MSB_LAST
      ECU_ADDRESS 0x25167
      ECU_ADDRESS_EXTENSION 0x0
      FORMAT "%.3"
      READ_WRITE
      SYMBOL_LINK "byte1" 0
      /begin IF_DATA CANAPE_EXT
        100
        LINK_MAP "byte1" 0x25167 0 0 0 1 0x87 0
        DISPLAY 0x0 0 255
      /end IF_DATA
    /end MEASUREMENT

    /begin MEASUREMENT byte2 "Demo, read and write possible"
      UBYTE NO_COMPU_METHOD 0 0 0 255
      BYTE_ORDER MSB_LAST
      ECU_ADDRESS 0x25166
      ECU_ADDRESS_EXTENSION 0x0
      FORMAT "%.3"
      READ_WRITE
      SYMBOL_LINK "byte2" 0
      /begin IF_DATA CANAPE_EXT
        100
        LINK_MAP "byte2" 0x25166 0 0 0 1 0x87 0
        DISPLAY 0x0 0 255
      /end IF_DATA
    /end MEASUREMENT

    /begin MEASUREMENT byte3 "Demo, read and write possible"
      SBYTE NO_COMPU_METHOD 0 0 0 255
      BYTE_ORDER MSB_LAST
      ECU_ADDRESS 0x25165
      ECU_ADDRESS_EXTENSION 0x0
      FORMAT "%.3"
      READ_WRITE
      SYMBOL_LINK "byte3" 0
      /begin IF_DATA CANAPE_EXT
        100
        LINK_MAP "byte3" 0x25165 0 0 0 1 0xC7 0
        DISPLAY 0x0 0 255
      /end IF_DATA
    /end MEASUREMENT

    /begin MEASUREMENT byte4 "Demo, read and write possible"
      UBYTE NO_COMPU_METHOD 0 0 0 255
      BYTE_ORDER MSB_LAST
      ECU_ADDRESS 0x25164
      ECU_ADDRESS_EXTENSION 0x0
      FORMAT "%.3"
      READ_WRITE
      SYMBOL_LINK "byte4" 0
      /begin IF_DATA CANAPE_EXT
        100
        LINK_MAP "byte4" 0x25164 0 0 0 1 0x87 0
        DISPLAY 0x0 0 255
      /end IF_DATA
    /end MEASUREMENT

    /begin CHARACTERISTIC byteArray1 ""
      VAL_BLK 0x32294 __UByte_Value 0 NO_COMPU_METHOD 0 255
      ECU_ADDRESS_EXTENSION 0x0
      EXTENDED_LIMITS 0 255
      FORMAT "%.15"
      MATRIX_DIM 1400
      SYMBOL_LINK "byteArray1" 0
      /begin IF_DATA CANAPE_EXT
        100
        LINK_MAP "byteArray1" 0x32294 0 0 0 1 0x87 0
        DISPLAY 0x0 0 255
      /end IF_DATA
    /end CHARACTERISTIC

    /begin CHARACTERISTIC byteArray10 ""
      VAL_BLK 0x35310 __UByte_Value 0 NO_COMPU_METHOD 0 255
      ECU_ADDRESS_EXTENSION 0x0
      EXTENDED_LIMITS 0 255
      FORMAT "%.15"
      MATRIX_DIM 1400
      SYMBOL_LINK "byteArray10" 0
      /begin IF_DATA CANAPE_EXT
        100
        LINK_MAP "byteArray10" 0x35310 0 0 0 1 0x87 0
        DISPLAY 0x0 0 255
      /end IF_DATA
    /end CHARACTERISTIC

    /begin CHARACTERISTIC byteArray11 ""
      VAL_BLK 0x30220 __UByte_Value 0 NO_COMPU_METHOD 0 255
      ECU_ADDRESS_EXTENSION 0x0
      EXTENDED_LIMITS 0 255
      FORMAT "%.15"
      MATRIX_DIM 1400
      SYMBOL_LINK "byteArray11" 0
      /begin IF_DATA CANAPE_EXT
        100
        LINK_MAP "byteArray11" 0x30220 0 0 0 1 0x87 0
        DISPLAY 0x0 0 255
      /end IF_DATA
    /end CHARACTERISTIC

    /begin CHARACTERISTIC byteArray12 ""
      VAL_BLK 0x31D1C __UByte_Value 0 NO_COMPU_METHOD 0 255
      ECU_ADDRESS_EXTENSION 0x0
      EXTENDED_LIMITS 0 255
      FORMAT "%.15"
      MATRIX_DIM 1400
      SYMBOL_LINK "byteArray12" 0
      /begin IF_DATA CANAPE_EXT
        100
        LINK_MAP "byteArray12" 0x31D1C 0 0 0 1 0x87 0
        DISPLAY 0x0 0 255
      /end IF_DATA
    /end CHARACTERISTIC

    /begin CHARACTERISTIC byteArray13 ""
      VAL_BLK 0x38970 __UByte_Value 0 NO_COMPU_METHOD 0 255
      ECU_ADDRESS_EXTENSION 0x0
      EXTENDED_LIMITS 0 255
      FORMAT "%.15"
      MATRIX_DIM 1400
      SYMBOL_LINK "byteArray13" 0
      /begin IF_DATA CANAPE_EXT
        100
        LINK_MAP "byteArray13" 0x38970 0 0 0 1 0x87 0
        DISPLAY 0x0 0 255
      /end IF_DATA
    /end CHARACTERISTIC

    /begin CHARACTERISTIC byteArray14 ""
      VAL_BLK 0x38EF8 __UByte_Value 0 NO_COMPU_METHOD 0 255
      ECU_ADDRESS_EXTENSION 0x0
      EXTENDED_LIMITS 0 255
      FORMAT "%.15"
      MATRIX_DIM 1400
      SYMBOL_LINK "byteArray14" 0
      /begin IF_DATA CANAPE_EXT
        100
        LINK_MAP "byteArray14" 0x38EF8 0 0 0 1 0x87 0
        DISPLAY 0x0 0 255
      /end IF_DATA
    /end CHARACTERISTIC

    /begin CHARACTERISTIC byteArray15 ""
      VAL_BLK 0x36E0C __UByte_Value 0 NO_COMPU_METHOD 0 255
      ECU_ADDRESS_EXTENSION 0x0
      EXTENDED_LIMITS 0 255
      FORMAT "%.15"
      MATRIX_DIM 1400
      SYMBOL_LINK "byteArray15" 0
      /begin IF_DATA CANAPE_EXT
        100
        LINK_MAP "byteArray15" 0x36E0C 0 0 0 1 0x87 0
        DISPLAY 0x0 0 255
      /end IF_DATA
    /end CHARACTERISTIC

    /begin CHARACTERISTIC byteArray16 ""
      VAL_BLK 0x37900 __UByte_Value 0 NO_COMPU_METHOD 0 255
      ECU_ADDRESS_EXTENSION 0x0
      EXTENDED_LIMITS 0 255
      FORMAT "%.15"
      MATRIX_DIM 1400
      SYMBOL_LINK "byteArray16" 0
      /begin IF_DATA CANAPE_EXT
        100
        LINK_MAP "byteArray16" 0x37900 0 0 0 1 0x87 0
        DISPLAY 0x0 0 255
      /end IF_DATA
    /end CHARACTERISTIC

    /begin CHARACTERISTIC byteArray2 ""
      VAL_BLK 0x37384 __UByte_Value 0 NO_COMPU_METHOD 0 255
      ECU_ADDRESS_EXTENSION 0x0
      EXTENDED_LIMITS 0 255
      FORMAT "%.15"
      MATRIX_DIM 1400
      SYMBOL_LINK "byteArray2" 0
      /begin IF_DATA CANAPE_EXT
        100
        LINK_MAP "byteArray2" 0x37384 0 0 0 1 0x87 0
        DISPLAY 0x0 0 255
      /end IF_DATA
    /end CHARACTERISTIC

    /begin CHARACTERISTIC byteArray3 ""
      VAL_BLK 0x35888 __UByte_Value 0 NO_COMPU_METHOD 0 255
      ECU_ADDRESS_EXTENSION 0x0
      EXTENDED_LIMITS 0 255
      FORMAT "%.15"
      MATRIX_DIM 1400
      SYMBOL_LINK "byteArray3" 0
      /begin IF_DATA CANAPE_EXT
        100
        LINK_MAP "byteArray3" 0x35888 0 0 0 1 0x87 0
        DISPLAY 0x0 0 255
      /end IF_DATA
    /end CHARACTERISTIC

    /begin CHARACTERISTIC byteArray4 ""
      VAL_BLK 0x383F8 __UByte_Value 0 NO_COMPU_METHOD 0 255
      ECU_ADDRESS_EXTENSION 0x0
      EXTENDED_LIMITS 0 255
      FORMAT "%.15"
      MATRIX_DIM 1400
      SYMBOL_LINK "byteArray4" 0
      /begin IF_DATA CANAPE_EXT
        100
        LINK_MAP "byteArray4" 0x383F8 0 0 0 1 0x87 0
        DISPLAY 0x0 0 255
      /end IF_DATA
    /end CHARACTERISTIC

    /begin CHARACTERISTIC byteArray5 ""
      VAL_BLK 0x37E78 __UByte_Value 0 NO_COMPU_METHOD 0 255
      ECU_ADDRESS_EXTENSION 0x0
      EXTENDED_LIMITS 0 255
      FORMAT "%.15"
      MATRIX_DIM 1400
      SYMBOL_LINK "byteArray5" 0
      /begin IF_DATA CANAPE_EXT
        100
        LINK_MAP "byteArray5" 0x37E78 0 0 0 1 0x87 0
        DISPLAY 0x0 0 255
      /end IF_DATA
    /end CHARACTERISTIC

    /begin CHARACTERISTIC byteArray6 ""
      VAL_BLK 0x30798 __UByte_Value 0 NO_COMPU_METHOD 0 255
      ECU_ADDRESS_EXTENSION 0x0
      EXTENDED_LIMITS 0 255
      FORMAT "%.15"
      MATRIX_DIM 1400
      SYMBOL_LINK "byteArray6" 0
      /begin IF_DATA CANAPE_EXT
        100
        LINK_MAP "byteArray6" 0x30798 0 0 0 1 0x87 0
        DISPLAY 0x0 0 255
      /end IF_DATA
    /end CHARACTERISTIC

    /begin CHARACTERISTIC byteArray7 ""
      VAL_BLK 0x39470 __UByte_Value 0 NO_COMPU_METHOD 0 255
      ECU_ADDRESS_EXTENSION 0x0
      EXTENDED_LIMITS 0 255
      FORMAT "%.15"
      MATRIX_DIM 1400
      SYMBOL_LINK "byteArray7" 0
      /begin IF_DATA CANAPE_EXT
        100
        LINK_MAP "byteArray7" 0x39470 0 0 0 1 0x87 0
        DISPLAY 0x0 0 255
      /end IF_DATA
    /end CHARACTERISTIC

    /begin CHARACTERISTIC byteArray8 ""
      VAL_BLK 0x33D94 __UByte_Value 0 NO_COMPU_METHOD 0 255
      ECU_ADDRESS_EXTENSION 0x0
      EXTENDED_LIMITS 0 255
      FORMAT "%.15"
      MATRIX_DIM 1400
      SYMBOL_LINK "byteArray8" 0
      /begin IF_DATA CANAPE_EXT
        100
        LINK_MAP "byteArray8" 0x33D94 0 0 0 1 0x87 0
        DISPLAY 0x0 0 255
      /end IF_DATA
    /end CHARACTERISTIC

    /begin CHARACTERISTIC byteArray9 ""
      VAL_BLK 0x3280C __UByte_Value 0 NO_COMPU_METHOD 0 255
      ECU_ADDRESS_EXTENSION 0x0
      EXTENDED_LIMITS 0 255
      FORMAT "%.15"
      MATRIX_DIM 1400
      SYMBOL_LINK "byteArray9" 0
      /begin IF_DATA CANAPE_EXT
        100
        LINK_MAP "byteArray9" 0x3280C 0 0 0 1 0x87 0
        DISPLAY 0x0 0 255
      /end IF_DATA
    /end CHARACTERISTIC

    /begin MEASUREMENT byteCounter "Demo signal (byte, incrementing)"
      UBYTE NO_COMPU_METHOD 0 0 0 255
      BYTE_ORDER MSB_LAST
      ECU_ADDRESS 0x3021C
      ECU_ADDRESS_EXTENSION 0x0
      FORMAT "%.3"
      SYMBOL_LINK "byteCounter" 0
      /begin IF_DATA CANAPE_EXT
        100
        LINK_MAP "byteCounter" 0x3021C 0 0 0 1 0x87 0
        DISPLAY 0x0 0 255
      /end IF_DATA
    /end MEASUREMENT

    /begin MEASUREMENT bytePWMFilter "Filter constant for PWM filter"
      UBYTE BitSlice.CONVERSION 0 0 0 100
      BYTE_ORDER MSB_LAST
      ECU_ADDRESS 0x25014
      ECU_ADDRESS_EXTENSION 0x0
      FORMAT "%.3"
      READ_WRITE
      SYMBOL_LINK "bytePWMFilter" 0
      /begin IF_DATA CANAPE_EXT
        100
        LINK_MAP "bytePWMFilter" 0x25014 0 0 0 1 0x87 0
        DISPLAY 0x0 0 100
      /end IF_DATA
    /end MEASUREMENT

    /begin CHARACTERISTIC c0 "Digital Filter v=(vin*a0+v*b0)/c0"
      VALUE 0x25016 __UWord_Value 0 DigitalFilterConversion 0 1
      BYTE_ORDER MSB_LAST
      ECU_ADDRESS_EXTENSION 0x0
      EXTENDED_LIMITS 0 1
      FORMAT "%.3"
      SYMBOL_LINK "c" 0
      /begin IF_DATA CANAPE_EXT
        100
        LINK_MAP "c" 0x25016 0 0 0 1 0x8F 0
        DISPLAY 0x0 0 1
      /end IF_DATA
    /end CHARACTERISTIC

    /begin MEASUREMENT channel1 "FLOAT demo signal (sine wave)"
      FLOAT32_IEEE NO_COMPU_METHOD 0 0 -1E+12 1E+12
      BYTE_ORDER MSB_LAST
      ECU_ADDRESS 0x35E04
      ECU_ADDRESS_EXTENSION 0x0
      FORMAT "%.3"
      SYMBOL_LINK "channel1" 0
      /begin IF_DATA CANAPE_EXT
        100
        LINK_MAP "channel1" 0x35E04 0 0 0 1 0x1 0
        DISPLAY 0x0 -100 100
      /end IF_DATA
    /end MEASUREMENT

    /begin MEASUREMENT channel2 "FLOAT demo signal (sine wave)"
      FLOAT32_IEEE NO_COMPU_METHOD 0 0 -1E+12 1E+12
      BYTE_ORDER MSB_LAST
      ECU_ADDRESS 0x38EEC
      ECU_ADDRESS_EXTENSION 0x0
      FORMAT "%.3"
      SYMBOL_LINK "channel2" 0
      /begin IF_DATA CANAPE_EXT
        100
        LINK_MAP "channel2" 0x38EEC 0 0 0 1 0x1 0
        DISPLAY 0x0 -100 100
      /end IF_DATA
    /end MEASUREMENT

    /begin MEASUREMENT channel3 "FLOAT demo signal (sine wave)"
      FLOAT32_IEEE NO_COMPU_METHOD 0 0 -100 100
      BYTE_ORDER MSB_LAST
      ECU_ADDRESS 0x383F4
      ECU_ADDRESS_EXTENSION 0x0
      FORMAT "%.3"
      SYMBOL_LINK "channel3" 0
      /begin IF_DATA CANAPE_EXT
        100
        LINK_MAP "channel3" 0x383F4 0 0 0 1 0x1 0
        DISPLAY 0x0 -100 100
      /end IF_DATA
    /end MEASUREMENT

    /begin MEASUREMENT channel4 ""
      FLOAT32_IEEE NO_COMPU_METHOD 0 0 -3.40282346639E+38 3.40282346639E+38
      ECU_ADDRESS 0x30D18
      ECU_ADDRESS_EXTENSION 0x0
      FORMAT "%.15"
      SYMBOL_LINK "channel4" 0
      /begin IF_DATA CANAPE_EXT
        100
        LINK_MAP "channel4" 0x30D18 0 0 0 1 0x1 0
        DISPLAY 0x0 -3.40282346639E+38 3.40282346639E+38
      /end IF_DATA
    /end MEASUREMENT

    /begin MEASUREMENT counter ""
      UWORD NO_COMPU_METHOD 0 0 0 65535
      ECU_ADDRESS 0x251B8
      SYMBOL_LINK "counter" 0
    /end MEASUREMENT

    /begin MEASUREMENT dto_buffer_ptr ""
      UBYTE NO_COMPU_METHOD 0 0 0 255
      ADDRESS_TYPE PLONG
      ECU_ADDRESS 0x25200
      SYMBOL_LINK "dto_buffer_ptr" 0
    /end MEASUREMENT

    /begin MEASUREMENT dto_queue_len ""
      ULONG NO_COMPU_METHOD 0 0 0 4294967295
      ECU_ADDRESS 0x251F8
      SYMBOL_LINK "dto_queue_len" 0
    /end MEASUREMENT

    /begin MEASUREMENT dto_queue_rp ""
      ULONG NO_COMPU_METHOD 0 0 0 4294967295
      ECU_ADDRESS 0x251FC
      SYMBOL_LINK "dto_queue_rp" 0
    /end MEASUREMENT

    /begin MEASUREMENT dwordCounter "Demo ECU task cacle counter"
      ULONG BitSlice.CONVERSION 0 0 0 255
      BYTE_ORDER MSB_LAST
      ECU_ADDRESS 0x32D88
      ECU_ADDRESS_EXTENSION 0x0
      FORMAT "%.3"
      SYMBOL_LINK "dwordCounter" 0
      /begin IF_DATA CANAPE_EXT
        100
        LINK_MAP "dwordCounter" 0x32D88 0 0 0 1 0x9F 0
        DISPLAY 0x0 0 255
      /end IF_DATA
    /end MEASUREMENT

    /begin INSTANCE ecu ""
      ecu 0x0
    /end INSTANCE

    /begin CHARACTERISTIC gCmdCycle "Command handler cycle time"
      VALUE 0x251A0 __ULong_Value 0 NO_COMPU_METHOD 0 4294967295
      PHYS_UNIT "us"
      SYMBOL_LINK "gCmdCycle" 0
    /end CHARACTERISTIC

    /begin CHARACTERISTIC gExit "Terminate application"
      VALUE 0x251CC __UByte_Value 0 NO_COMPU_METHOD 0 255
      SYMBOL_LINK "gExit" 0
    /end CHARACTERISTIC

    /begin CHARACTERISTIC gFlushCycle "Flush cycle time"
      VALUE 0x251A4 __ULong_Value 0 NO_COMPU_METHOD 0 4294967295
      PHYS_UNIT "us"
      SYMBOL_LINK "gFlushCycle" 0
    /end CHARACTERISTIC

    /begin CHARACTERISTIC gTaskCycleTimerECU "ECU cycle time (ns delay)"
      VALUE 0x251A8 __ULong_Value 0 NO_COMPU_METHOD 0 4294967295
      EXTENDED_LIMITS 0 4294967295
      PHYS_UNIT "ns"
      SYMBOL_LINK "gTaskCycleTimerECU" 0
    /end CHARACTERISTIC

    /begin CHARACTERISTIC gTaskCycleTimerECUpp "ECU cycle time (ns delay)"
      VALUE 0x251AC __ULong_Value 0 NO_COMPU_METHOD 0 4294967295
      EXTENDED_LIMITS 0 4294967295
      PHYS_UNIT "ns"
      SYMBOL_LINK "gTaskCycleTimerECUpp" 0
    /end CHARACTERISTIC

    /begin CHARACTERISTIC gTaskCycleTimerServer "Server loop cycle time (ns delay)"
      VALUE 0x2519C __ULong_Value 0 NO_COMPU_METHOD 0 4294967295
      PHYS_UNIT "ns"
      SYMBOL_LINK "gTaskCycleTimerServer" 0
    /end CHARACTERISTIC

    /begin CHARACTERISTIC gXcpDebugLevel "Debug verbosity"
      VALUE 0x30204 __UByte_Value 0 NO_COMPU_METHOD 0 255
      SYMBOL_LINK "gXcpDebugLevel" 0
    /end CHARACTERISTIC

    /begin CHARACTERISTIC gXcpStationId "A2L filename"
      VALUE 0x14160 __UByte_Value 0 NO_COMPU_METHOD 0 255
      SYMBOL_LINK "gXcpStationId" 0
    /end CHARACTERISTIC

    /begin MEASUREMENT limit "Limit for channel1"
      FLOAT32_IEEE NO_COMPU_METHOD 0 0 -1E+12 1E+12
      BYTE_ORDER MSB_LAST
      ECU_ADDRESS 0x25010
      ECU_ADDRESS_EXTENSION 0x0
      FORMAT "%.3"
      READ_WRITE
      SYMBOL_LINK "limit" 0
      /begin IF_DATA CANAPE_EXT
        100
        LINK_MAP "limit" 0x25010 0 0 0 1 0x1 0
        DISPLAY 0x0 0 100
      /end IF_DATA
    /end MEASUREMENT

    /begin CHARACTERISTIC longArray1 ""
      VAL_BLK 0x35E0C __ULong_Value 0 NO_COMPU_METHOD 0 255
      ECU_ADDRESS_EXTENSION 0x0
      EXTENDED_LIMITS 0 255
      FORMAT "%.15"
      MATRIX_DIM 1024
      SYMBOL_LINK "longArray1" 0
      /begin IF_DATA CANAPE_EXT
        100
        LINK_MAP "longArray1" 0x35E0C 0 0 0 1 0x9F 0
        DISPLAY 0x0 0 255
      /end IF_DATA
    /end CHARACTERISTIC

    /begin CHARACTERISTIC longArray2 ""
      VAL_BLK 0x34310 __ULong_Value 0 NO_COMPU_METHOD 0 255
      ECU_ADDRESS_EXTENSION 0x0
      EXTENDED_LIMITS 0 255
      FORMAT "%.15"
      MATRIX_DIM 1024
      SYMBOL_LINK "longArray2" 0
      /begin IF_DATA CANAPE_EXT
        100
        LINK_MAP "longArray2" 0x34310 0 0 0 1 0x9F 0
        DISPLAY 0x0 0 255
      /end IF_DATA
    /end CHARACTERISTIC

    /begin CHARACTERISTIC longArray3 ""
      VAL_BLK 0x32D90 __ULong_Value 0 NO_COMPU_METHOD 0 255
      ECU_ADDRESS_EXTENSION 0x0
      EXTENDED_LIMITS 0 255
      FORMAT "%.15"
      MATRIX_DIM 1024
      SYMBOL_LINK "longArray3" 0
      /begin IF_DATA CANAPE_EXT
        100
        LINK_MAP "longArray3" 0x32D90 0 0 0 1 0x9F 0
        DISPLAY 0x0 0 255
      /end IF_DATA
    /end CHARACTERISTIC

    /begin CHARACTERISTIC longArray4 ""
      VAL_BLK 0x30D1C __ULong_Value 0 NO_COMPU_METHOD 0 255
      ECU_ADDRESS_EXTENSION 0x0
      EXTENDED_LIMITS 0 255
      FORMAT "%.15"
      MATRIX_DIM 1024
      SYMBOL_LINK "longArray4" 0
      /begin IF_DATA CANAPE_EXT
        100
        LINK_MAP "longArray4" 0x30D1C 0 0 0 1 0x9F 0
        DISPLAY 0x0 0 255
      /end IF_DATA
    /end CHARACTERISTIC

    /begin CHARACTERISTIC map1 "8*8 BYTE shared axis Curve1/Curve1"
      MAP 0x25108 MapV88ub 0 map1Conversion 0 2550
      /begin AXIS_DESCR
        FIX_AXIS map1InputX map1Input_Conversion 8 -12.8 12.7
        EXTENDED_LIMITS -12.8 12.7
        FIX_AXIS_PAR_DIST 0 1 8
        FORMAT "%.3"
      /end AXIS_DESCR
      /begin AXIS_DESCR
        FIX_AXIS map1InputY map1Input_Conversion 8 -12.8 12.7
        EXTENDED_LIMITS -12.8 12.7
        FIX_AXIS_PAR_DIST 0 1 8
        FORMAT "%.3"
      /end AXIS_DESCR
      BYTE_ORDER MSB_LAST
      ECU_ADDRESS_EXTENSION 0x0
      EXTENDED_LIMITS 0 2550
      FORMAT "%.3"
      SYMBOL_LINK "map1_8_8_uc" 0
      /begin IF_DATA CANAPE_EXT
        100
        LINK_MAP "map1_8_8_uc" 0x25108 0 0 0 1 0x87 0
        DISPLAY 0x0 0 255
      /end IF_DATA
    /end CHARACTERISTIC

    /begin CHARACTERISTIC map2 "8*8 BYTE shared axis Curve1/Curve1"
      MAP 0x250C8 MapV88ub 0 map1Conversion 0 2550
      /begin AXIS_DESCR
        FIX_AXIS map1InputX map1Input_Conversion 8 -12.8 12.7
        EXTENDED_LIMITS -12.8 12.7
        FIX_AXIS_PAR_DIST 0 1 8
        FORMAT "%.3"
      /end AXIS_DESCR
      /begin AXIS_DESCR
        FIX_AXIS map1InputY map1Input_Conversion 8 -12.8 12.7
        EXTENDED_LIMITS -12.8 12.7
        FIX_AXIS_PAR_DIST 0 1 8
        FORMAT "%.3"
      /end AXIS_DESCR
      BYTE_ORDER MSB_LAST
      ECU_ADDRESS_EXTENSION 0x0
      EXTENDED_LIMITS 0 2550
      FORMAT "%.3"
      SYMBOL_LINK "map2_8_8_uc" 0
      /begin IF_DATA CANAPE_EXT
        100
        LINK_MAP "map2_8_8_uc" 0x250C8 0 0 0 1 0x87 0
        DISPLAY 0x0 0 255
      /end IF_DATA
    /end CHARACTERISTIC

    /begin MEASUREMENT offset "Offset for channel1"
      FLOAT32_IEEE NO_COMPU_METHOD 0 0 -1E+12 1E+12
      BYTE_ORDER MSB_LAST
      ECU_ADDRESS 0x251BC
      ECU_ADDRESS_EXTENSION 0x0
      FORMAT "%.3"
      READ_WRITE
      SYMBOL_LINK "offset" 0
      /begin IF_DATA CANAPE_EXT
        100
        LINK_MAP "offset" 0x251BC 0 0 0 1 0x1 0
        DISPLAY 0x0 0 100
      /end IF_DATA
    /end MEASUREMENT

    /begin MEASUREMENT period "Period of channel 1-3"
      FLOAT32_IEEE NO_COMPU_METHOD 0 0 0 100
      BYTE_ORDER MSB_LAST
      ECU_ADDRESS 0x25008
      ECU_ADDRESS_EXTENSION 0x0
      FORMAT "%.3"
      READ_WRITE
      SYMBOL_LINK "period" 0
      /begin IF_DATA CANAPE_EXT
        100
        LINK_MAP "period" 0x25008 0 0 0 1 0x1 0
        DISPLAY 0x0 0 100
      /end IF_DATA
    /end MEASUREMENT

    /begin MEASUREMENT sbytePWMLevel ""
      SBYTE sbytePWMLevel.CONVERSION 0 0 0 255
      ECU_ADDRESS 0x251C0
      ECU_ADDRESS_EXTENSION 0x0
      FORMAT "%.15"
      SYMBOL_LINK "sbytePWMLevel" 0
      /begin IF_DATA CANAPE_EXT
        100
        LINK_MAP "sbytePWMLevel" 0x251C0 0 0 0 1 0xC7 0
        DISPLAY 0x0 0 255
      /end IF_DATA
    /end MEASUREMENT

    /begin CHARACTERISTIC testString "vcv"
      ASCII 0x2518C __UByte_Value 0 NO_COMPU_METHOD 0 255
      ECU_ADDRESS_EXTENSION 0x0
      EXTENDED_LIMITS 0 255
      NUMBER 10
      SYMBOL_LINK "testString" 0
      /begin IF_DATA CANAPE_EXT
        100
        LINK_MAP "testString" 0x2518C 0 0 0 1 0x87 0
        DISPLAY 0x0 0 255
      /end IF_DATA
    /end CHARACTERISTIC

    /begin MEASUREMENT v "Digital Filter Outputvalue"
      UWORD DigitalFilterConversion 0 0 0 1
      BYTE_ORDER MSB_LAST
      ECU_ADDRESS 0x32D8C
      ECU_ADDRESS_EXTENSION 0x0
      FORMAT "%.3"
      READ_WRITE
      SYMBOL_LINK "v" 0
      /begin IF_DATA CANAPE_EXT
        100
        LINK_MAP "v" 0x32D8C 0 0 0 1 0x8F 0
        DISPLAY 0x0 0 1
      /end IF_DATA
    /end MEASUREMENT

    /begin MEASUREMENT vin "Digital Filter Inputvalue"
      UWORD DigitalFilterConversion 0 0 0 1
      BYTE_ORDER MSB_LAST
      ECU_ADDRESS 0x33D90
      ECU_ADDRESS_EXTENSION 0x0
      FORMAT "%.3"
      READ_WRITE
      SYMBOL_LINK "vin" 0
      /begin IF_DATA CANAPE_EXT
        100
        LINK_MAP "vin" 0x33D90 0 0 0 1 0x8F 0
        DISPLAY 0x0 0 1
      /end IF_DATA
    /end MEASUREMENT

    /begin MEASUREMENT wordCounter "Demo signal (word, incrementing)"
      UWORD NO_COMPU_METHOD 0 0 0 65535
      BYTE_ORDER MSB_LAST
      ECU_ADDRESS 0x383F0
      ECU_ADDRESS_EXTENSION 0x0
      FORMAT "%.3"
      SYMBOL_LINK "wordCounter" 0
      /begin IF_DATA CANAPE_EXT
        100
        LINK_MAP "wordCounter" 0x383F0 0 0 0 1 0x8F 0
        DISPLAY 0x0 0 255
      /end IF_DATA
    /end MEASUREMENT

    /begin COMPU_METHOD BitSlice.CONVERSION ""
      IDENTICAL "%6.2f" ""
    /end COMPU_METHOD

    /begin COMPU_METHOD Current "Convert Voltage into Current"
      FORM "%7.3" ""
      /begin FORMULA
        "X*X*2"
      /end FORMULA
    /end COMPU_METHOD

    /begin COMPU_METHOD DigitalFilterConversion ""
      LINEAR "%3.1" "Volt"
      COEFFS_LINEAR 0.001 0
    /end COMPU_METHOD

    /begin COMPU_METHOD DtChannel1.CONVERSIONV "@@@@RuleName created by CANape"
      FORM "%3.1" ""
      /begin FORMULA
        "time(X1)-time(X1[-1])"
      /end FORMULA
    /end COMPU_METHOD

    /begin COMPU_METHOD Factor100 ""
      LINEAR "%3.1" ""
      COEFFS_LINEAR 0.01 0
    /end COMPU_METHOD

    /begin COMPU_METHOD HighLow "High/Low for bits"
      TAB_VERB "%7.3" ""
      COMPU_TAB_REF HighLow
    /end COMPU_METHOD

    /begin COMPU_METHOD KF8_Conversion ""
      LINEAR "%3.1" "1/min"
      COEFFS_LINEAR 0.1 0
    /end COMPU_METHOD

    /begin COMPU_METHOD MaxChannel1.CONVERSIONV "@@@@RuleName created by CANape"
      FORM "%3.1" ""
      /begin FORMULA
        "max(phy(X1))"
      /end FORMULA
    /end COMPU_METHOD

    /begin COMPU_METHOD MinChannel1.CONVERSIONV "@@@@RuleName created by CANape"
      FORM "%3.1" ""
      /begin FORMULA
        "min(phy(X1))"
      /end FORMULA
    /end COMPU_METHOD

    /begin COMPU_METHOD Pressure "Convert Voltage into Pressure"
      LINEAR "%7.3" ""
      COEFFS_LINEAR 0.123457 0
    /end COMPU_METHOD

    /begin COMPU_METHOD TestStatus.CONVERSION ""
      TAB_VERB "%3.1" ""
      COMPU_TAB_REF TestStatus.CONVERSION
    /end COMPU_METHOD

    /begin COMPU_METHOD map1Conversion ""
      LINEAR "%3.1" "cm"
      COEFFS_LINEAR 10 0
    /end COMPU_METHOD

    /begin COMPU_METHOD map1Input_Conversion ""
      LINEAR "%3.1" "m"
      COEFFS_LINEAR 0.1 0
    /end COMPU_METHOD

    /begin COMPU_METHOD sbytePWMLevel.CONVERSION ""
      IDENTICAL "%6.2" ""
    /end COMPU_METHOD

    /begin COMPU_VTAB HighLow "High/Low for bits" TAB_VERB 2
      0 "Low"
      1 "High"
      DEFAULT_VALUE ""
    /end COMPU_VTAB

    /begin COMPU_VTAB TestStatus.CONVERSION "" TAB_VERB 4
      0 "Off"
      1 "Silent"
      2 "Pending"
      3 "Running"
      DEFAULT_VALUE ""
    /end COMPU_VTAB

    /begin RECORD_LAYOUT CurveNxVub
      AXIS_PTS_X 1 UBYTE INDEX_INCR DIRECT
      FNC_VALUES 2 UBYTE ROW_DIR DIRECT
    /end RECORD_LAYOUT

    /begin RECORD_LAYOUT CurveNxXVub
      NO_AXIS_PTS_X 1 UBYTE
      AXIS_PTS_X 2 UBYTE INDEX_INCR DIRECT
      FNC_VALUES 3 UBYTE ROW_DIR DIRECT
    /end RECORD_LAYOUT

    /begin RECORD_LAYOUT CurveV8ub
      FNC_VALUES 1 UBYTE ROW_DIR DIRECT
      FIX_NO_AXIS_PTS_X 8
    /end RECORD_LAYOUT

    /begin RECORD_LAYOUT CurveX8V8ub
      AXIS_PTS_X 1 UBYTE INDEX_INCR DIRECT
      FNC_VALUES 2 UBYTE ROW_DIR DIRECT
      FIX_NO_AXIS_PTS_X 8
    /end RECORD_LAYOUT

    /begin RECORD_LAYOUT CurveX8V8ubAlternate
      AXIS_PTS_X 1 UWORD INDEX_INCR DIRECT
      FNC_VALUES 2 UWORD ALTERNATE_WITH_X DIRECT
      FIX_NO_AXIS_PTS_X 8
    /end RECORD_LAYOUT

    /begin RECORD_LAYOUT CurveX8ub
      AXIS_PTS_X 1 UBYTE INDEX_INCR DIRECT
      FIX_NO_AXIS_PTS_X 8
    /end RECORD_LAYOUT

    /begin RECORD_LAYOUT MapNxNyVub
      NO_AXIS_PTS_X 1 UBYTE
      NO_AXIS_PTS_Y 2 UBYTE
      FNC_VALUES 3 UBYTE ROW_DIR DIRECT
    /end RECORD_LAYOUT

    /begin RECORD_LAYOUT MapNxNyXYVsb
      NO_AXIS_PTS_X 1 SBYTE
      NO_AXIS_PTS_Y 2 SBYTE
      AXIS_PTS_X 3 SBYTE INDEX_INCR DIRECT
      AXIS_PTS_Y 4 SBYTE INDEX_INCR DIRECT
      FNC_VALUES 5 SBYTE ROW_DIR DIRECT
      ALIGNMENT_BYTE 1
    /end RECORD_LAYOUT

    /begin RECORD_LAYOUT MapNxNyXYVub
      NO_AXIS_PTS_X 1 UBYTE
      NO_AXIS_PTS_Y 2 UBYTE
      AXIS_PTS_X 3 UBYTE INDEX_INCR DIRECT
      AXIS_PTS_Y 4 UBYTE INDEX_INCR DIRECT
      FNC_VALUES 5 UBYTE ROW_DIR DIRECT
    /end RECORD_LAYOUT

    /begin RECORD_LAYOUT MapNxXNyYVuc
      NO_AXIS_PTS_X 1 UBYTE
      AXIS_PTS_X 2 UBYTE INDEX_INCR DIRECT
      NO_AXIS_PTS_Y 3 UBYTE
      AXIS_PTS_Y 4 UBYTE INDEX_INCR DIRECT
      FNC_VALUES 5 UBYTE ROW_DIR DIRECT
    /end RECORD_LAYOUT

    /begin RECORD_LAYOUT MapV86ub
      FNC_VALUES 1 UBYTE ROW_DIR DIRECT
      FIX_NO_AXIS_PTS_X 8
      FIX_NO_AXIS_PTS_Y 6
    /end RECORD_LAYOUT

    /begin RECORD_LAYOUT MapV88ub
      FNC_VALUES 1 UBYTE ROW_DIR DIRECT
      FIX_NO_AXIS_PTS_X 8
      FIX_NO_AXIS_PTS_Y 8
    /end RECORD_LAYOUT

    /begin RECORD_LAYOUT MapX8Y6V86ub
      AXIS_PTS_X 1 UBYTE INDEX_INCR DIRECT
      AXIS_PTS_Y 2 UBYTE INDEX_INCR DIRECT
      FNC_VALUES 3 UBYTE ROW_DIR DIRECT
      FIX_NO_AXIS_PTS_X 8
      FIX_NO_AXIS_PTS_Y 6
    /end RECORD_LAYOUT

    /begin RECORD_LAYOUT MapX8Y8V88ub
      AXIS_PTS_X 1 UBYTE INDEX_INCR DIRECT
      AXIS_PTS_Y 2 UBYTE INDEX_INCR DIRECT
      FNC_VALUES 3 UBYTE ROW_DIR DIRECT
      FIX_NO_AXIS_PTS_X 8
      FIX_NO_AXIS_PTS_Y 8
    /end RECORD_LAYOUT

    /begin RECORD_LAYOUT MapXYVub
      AXIS_PTS_X 1 UBYTE INDEX_INCR DIRECT
      AXIS_PTS_Y 2 UBYTE INDEX_INCR DIRECT
      FNC_VALUES 3 UBYTE ROW_DIR DIRECT
    /end RECORD_LAYOUT

    /begin RECORD_LAYOUT __UByte_Value
      FNC_VALUES 1 UBYTE ROW_DIR DIRECT
    /end RECORD_LAYOUT

    /begin RECORD_LAYOUT __ULong_Value
      FNC_VALUES 1 ULONG ROW_DIR DIRECT
    /end RECORD_LAYOUT

    /begin RECORD_LAYOUT __UWord_Value
      FNC_VALUES 1 UWORD ROW_DIR DIRECT
    /end RECORD_LAYOUT

    /begin GROUP Example_Filter "Digital Filter v=(vin*a0+v*b0)/c0"
      /begin REF_MEASUREMENT
        v vin
      /end REF_MEASUREMENT
      /begin SUB_GROUP
        Filter_Parameters
      /end SUB_GROUP
    /end GROUP

    /begin GROUP Example_PWM "Generator for a PWM Signal"
      /begin REF_MEASUREMENT
        PWM PWMFiltered Triangle
      /end REF_MEASUREMENT
      /begin SUB_GROUP
        PWM_Parameters
      /end SUB_GROUP
    /end GROUP

    /begin GROUP Filter_Parameters ""
      /begin REF_CHARACTERISTIC
        a0 b0 c0
      /end REF_CHARACTERISTIC
    /end GROUP

    /begin GROUP PWM_Parameters "Parametes for PWM Example"
      /begin REF_MEASUREMENT
        FW1 PWM_Level bytePWMFilter sbytePWMLevel
      /end REF_MEASUREMENT
    /end GROUP

    /begin GROUP TaskECU ""
      /begin REF_CHARACTERISTIC
        byteArray1 byteArray10 byteArray11 byteArray12 byteArray13 byteArray14 byteArray15
        byteArray16 byteArray2 byteArray3 byteArray4 byteArray5 byteArray6 byteArray7 byteArray8
        byteArray9 longArray1 longArray2 longArray3 longArray4
      /end REF_CHARACTERISTIC
      /begin REF_MEASUREMENT
        ampl byte1 byte2 byte3 byte4 byteCounter channel1
        channel2 channel3 channel4 counter limit offset period wordCounter
      /end REF_MEASUREMENT
      /begin SUB_GROUP
        Example_Filter Example_PWM
      /end SUB_GROUP
    /end GROUP

    /begin GROUP TaskECUpp ""
      /begin REF_MEASUREMENT
        ecu
      /end REF_MEASUREMENT
    /end GROUP

    /begin GROUP Test_Parameters "Test Parameters, BYTE"
      /begin REF_CHARACTERISTIC
        CALRAM_LAST CALRAM_SIGN CALRAM_START gCmdCycle gDebugLevel gExit gFlushCycle
        gSocketTimeout gTaskCycle gTaskCycleTimerCMD gTaskCycleTimerDAQ gTaskCycleTimerECU gTaskCycleTimerECUpp gTaskCycleTimerServer gXcpDebugLevel
        gXcpDebugLevel_Copy1 gXcpStationId
      /end REF_CHARACTERISTIC
    /end GROUP

    /begin GROUP Test_Signals "Test Signals"
      /begin REF_MEASUREMENT
        dto_buffer_ptr dto_queue_len dto_queue_rp dwordCounter
      /end REF_MEASUREMENT
    /end GROUP

  /end MODULE

/end PROJECT
