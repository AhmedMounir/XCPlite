ASAP2_VERSION 1 70
/begin PROJECT CSM "D:\\USR\\RaspberryPi\\xcpLite\\CANape19\\CSM.a2l"
  /begin MODULE XCPGateway "XCPGateway"
    /begin A2ML
      /***********************************************************/
      /*                                                         */
      /*   ASAP2 meta language for XCP protocol layer V1.4       */
      /*                                                         */
      /*                                                         */
      /*   Datatypes:                                            */
      /*                                                         */
      /*   A2ML       description                                */
      /*   ---------------------------------------------------   */
      /*   uchar      unsigned 8 Bit                             */
      /*   char       signed 8 Bit                               */
      /*   uint       unsigned integer 16 Bit                    */
      /*   int        signed integer 16 Bit                      */
      /*   ulong      unsigned integer 32 Bit                    */
      /*   long       signed integer 32 Bit                      */
      /*   int64      signed integer 64 Bit                      */
      /*   uint64     unsigned integer 64 Bit                    */
      /*   float      float point 32 Bit IEEE 754                */
      /*   double     float point 64 Bit IEEE 754                */
      /*                                                         */
      /***********************************************************/
      
      /*************** start of PROTOCOL_LAYER *******************/
      
      struct Protocol_Layer {                                   /* At MODULE */
      
        uint;                                                   /* XCP protocol layer version */
                                                                /* "1.4" = 0x0104 */
      
        uint;                                                   /* T1 [ms] */
        uint;                                                   /* T2 [ms] */
        uint;                                                   /* T3 [ms] */
        uint;                                                   /* T4 [ms] */
        uint;                                                   /* T5 [ms] */
        uint;                                                   /* T6 [ms] */
        uint;                                                   /* T7 [ms] */
      
        uchar;                                                  /* MAX_CTO */
        uint;                                                   /* MAX_DTO default for DAQ and STIM */
      
        enum {                                                  /* BYTE_ORDER */
          "BYTE_ORDER_MSB_LAST"  = 0,
          "BYTE_ORDER_MSB_FIRST" = 1
        };
      
        enum {                                                  /* ADDRESS_GRANULARITY */
          "ADDRESS_GRANULARITY_BYTE"    = 1,
          "ADDRESS_GRANULARITY_WORD"    = 2,
          "ADDRESS_GRANULARITY_DWORD"   = 4
        };
      
        taggedstruct {                                          /* optional */
      
          ("OPTIONAL_CMD" enum {                                /* XCP-Code of optional level 0 commands */
                                                                /* supported by the slave */
            "GET_COMM_MODE_INFO"               = 0xFB,
            "GET_ID"                           = 0xFA,
            "SET_REQUEST"                      = 0xF9,
            "GET_SEED"                         = 0xF8,
            "UNLOCK"                           = 0xF7,
            "SET_MTA"                          = 0xF6,
            "UPLOAD"                           = 0xF5,
            "SHORT_UPLOAD"                     = 0xF4,
            "BUILD_CHECKSUM"                   = 0xF3,
            "TRANSPORT_LAYER_CMD"              = 0xF2,
            "USER_CMD"                         = 0xF1,
            "DOWNLOAD"                         = 0xF0,
            "DOWNLOAD_NEXT"                    = 0xEF,
            "DOWNLOAD_MAX"                     = 0xEE,
            "SHORT_DOWNLOAD"                   = 0xED,
            "MODIFY_BITS"                      = 0xEC,
            "SET_CAL_PAGE"                     = 0xEB,
            "GET_CAL_PAGE"                     = 0xEA,
            "GET_PAG_PROCESSOR_INFO"           = 0xE9,
            "GET_SEGMENT_INFO"                 = 0xE8,
            "GET_PAGE_INFO"                    = 0xE7,
            "SET_SEGMENT_MODE"                 = 0xE6,
            "GET_SEGMENT_MODE"                 = 0xE5,
            "COPY_CAL_PAGE"                    = 0xE4,
            "CLEAR_DAQ_LIST"                   = 0xE3,
            "SET_DAQ_PTR"                      = 0xE2,
            "WRITE_DAQ"                        = 0xE1,
            "SET_DAQ_LIST_MODE"                = 0xE0,
            "GET_DAQ_LIST_MODE"                = 0xDF,
            "START_STOP_DAQ_LIST"              = 0xDE,
            "START_STOP_SYNCH"                 = 0xDD,
            "GET_DAQ_CLOCK"                    = 0xDC,
            "READ_DAQ"                         = 0xDB,
            "GET_DAQ_PROCESSOR_INFO"           = 0xDA,
            "GET_DAQ_RESOLUTION_INFO"          = 0xD9,
            "GET_DAQ_LIST_INFO"                = 0xD8,
            "GET_DAQ_EVENT_INFO"               = 0xD7,
            "FREE_DAQ"                         = 0xD6,
            "ALLOC_DAQ"                        = 0xD5,
            "ALLOC_ODT"                        = 0xD4,
            "ALLOC_ODT_ENTRY"                  = 0xD3,
            "PROGRAM_START"                    = 0xD2,
            "PROGRAM_CLEAR"                    = 0xD1,
            "PROGRAM"                          = 0xD0,
            "PROGRAM_RESET"                    = 0xCF,
            "GET_PGM_PROCESSOR_INFO"           = 0xCE,
            "GET_SECTOR_INFO"                  = 0xCD,
            "PROGRAM_PREPARE"                  = 0xCC,
            "PROGRAM_FORMAT"                   = 0xCB,
            "PROGRAM_NEXT"                     = 0xCA,
            "PROGRAM_MAX"                      = 0xC9,
            "PROGRAM_VERIFY"                   = 0xC8,
            "WRITE_DAQ_MULTIPLE"               = 0xC7,
            "TIME_CORRELATION_PROPERTIES"      = 0xC6,
            "DTO_CTR_PROPERTIES"               = 0xC5
                                                                /* do not use 0xC0 command code here, it is reserved as command extension code */
          })*;
      
          ("OPTIONAL_LEVEL1_CMD" enum {                         /* XCP-Code of optional level 1 commands, starting with level 0 0xC0 as first byte */
            "GET_VERSION"                      = 0x00,
            "SET_DAQ_PACKED_MODE"              = 0x01,
            "GET_DAQ_PACKED_MODE"              = 0x02,
            "SW_DBG_COMMAND_SPACE"             = 0xFC,
            "POD_COMMAND_SPACE"                = 0xFD
                                                                /* 0xFE shall not be used */
                                                                /* 0xFF reserved for optional level 2 command space extension */
          })*;
      
          "COMMUNICATION_MODE_SUPPORTED" taggedunion {          /* optional modes supported */
            "BLOCK" taggedstruct {
              "SLAVE";                                          /* Slave Block Mode supported */
              "MASTER" struct {                                 /* Master Block Mode supported */
                uchar;                                          /* MAX_BS */
                uchar;                                          /* MIN_ST */
              };
            };
            "INTERLEAVED" uchar;                                /* QUEUE_SIZE */
          };
      
          "SEED_AND_KEY_EXTERNAL_FUNCTION" char[256];           /* Name of the Seed&Key function */
                                                                /* including file extension */
                                                                /* without path */
          "MAX_DTO_STIM" uint;                                  /* overrules MAX_DTO see above for STIM use case */
      
          block "ECU_STATES" taggedstruct{
      
            (block "STATE" struct{
              uchar;                                            /* STATE_NUMBER */
              char[100];                                        /* STATE_NAME */
              taggedstruct {
                "ECU_SWITCHED_TO_DEFAULT_PAGE";
              };
              enum {                                            /* CAL/PAG RESOURCE */
                "NOT_ACTIVE" = 0,
                "ACTIVE" = 1,
                "GETTER_ONLY" = 2                               /* Setter methods not allowed */
              };
              enum {                                            /* DAQ RESOURCE */
                "NOT_ACTIVE" = 0,
                "ACTIVE" = 1
              };
              enum {                                            /* STIM RESOURCE */
                "NOT_ACTIVE" = 0,
                "ACTIVE" = 1
              };
              enum {                                            /* PGM RESOURCE */
                "NOT_ACTIVE" = 0,
                "ACTIVE" = 1
              };
      
              taggedstruct {
      
                (block "MEMORY_ACCESS" struct{                  /* CAL/PAG AVAILABLE */
                  uchar;                                        /* SEGMENT_NUMBER */
                  uchar;                                        /* PAGE_NUMBER */
                  enum {
                    "READ_ACCESS_NOT_ALLOWED" = 0,
                    "READ_ACCESS_ALLOWED" = 1
                  };
                  enum {
                    "WRITE_ACCESS_NOT_ALLOWED" = 0,
                    "WRITE_ACCESS_ALLOWED" = 1
                  };
                })*;
      
              };
      
            })*;
      
          };
      
        };
      
      };
      
      /***************** end of PROTOCOL_LAYER *******************/
      
      
      
      /********************* start of DAQ ************************/
      
      struct Daq {                                              /* DAQ supported, at MODULE */
        enum {                                                  /* DAQ_CONFIG_TYPE */
          "STATIC"  = 0,
          "DYNAMIC" = 1
        };
      
        uint;                                                   /* MAX_DAQ */
        uint;                                                   /* MAX_EVENT_CHANNEL */
        uchar;                                                  /* MIN_DAQ */
      
        enum {                                                  /* OPTIMISATION_TYPE */
          "OPTIMISATION_TYPE_DEFAULT"            = 0,
          "OPTIMISATION_TYPE_ODT_TYPE_16"        = 1,
          "OPTIMISATION_TYPE_ODT_TYPE_32"        = 2,
          "OPTIMISATION_TYPE_ODT_TYPE_64"        = 3,
          "OPTIMISATION_TYPE_ODT_TYPE_ALIGNMENT" = 4,
          "OPTIMISATION_TYPE_MAX_ENTRY_SIZE"     = 5
        };
      
        enum {                                                  /* ADDRESS_EXTENSION */
          "ADDRESS_EXTENSION_FREE" = 0,
          "ADDRESS_EXTENSION_ODT"  = 1,
          "ADDRESS_EXTENSION_DAQ"  = 3
        };
      
      
        enum {                                                  /* IDENTIFICATION_FIELD */
          "IDENTIFICATION_FIELD_TYPE_ABSOLUTE"                       = 0,
          "IDENTIFICATION_FIELD_TYPE_RELATIVE_BYTE"                  = 1,
          "IDENTIFICATION_FIELD_TYPE_RELATIVE_WORD"         = 2,
          "IDENTIFICATION_FIELD_TYPE_RELATIVE_WORD_ALIGNED" = 3
        };
      
      
        enum {                                                  /* GRANULARITY_ODT_ENTRY_SIZE_DAQ */
          "GRANULARITY_ODT_ENTRY_SIZE_DAQ_BYTE"    = 1,
          "GRANULARITY_ODT_ENTRY_SIZE_DAQ_WORD"    = 2,
          "GRANULARITY_ODT_ENTRY_SIZE_DAQ_DWORD"   = 4,
          "GRANULARITY_ODT_ENTRY_SIZE_DAQ_DLONG"   = 8
        };
      
        uchar;                                                  /* MAX_ODT_ENTRY_SIZE_DAQ */
      
        enum {                                                  /* OVERLOAD_INDICATION */
          "NO_OVERLOAD_INDICATION"    = 0,
          "OVERLOAD_INDICATION_PID"   = 1,
          "OVERLOAD_INDICATION_EVENT" = 2
        };
      
        taggedstruct {                                          /* optional */
          "DAQ_ALTERNATING_SUPPORTED" uint;                     /* Display_Event_Channel_Number */
          "PRESCALER_SUPPORTED";
          "RESUME_SUPPORTED";
          "STORE_DAQ_SUPPORTED";
          "DTO_CTR_FIELD_SUPPORTED";
          "OPTIMISATION_TYPE_ODT_STRICT";                       /* strict mode shall only be used in combination with */
                                                                /* OPTIMISATION_TYPE_ODT_TYPE_16 */
                                                                /* OPTIMISATION_TYPE_ODT_TYPE_32 */
                                                                /* OPTIMISATION_TYPE_ODT_TYPE_64 */
      
          block "STIM" struct {                                 /* STIM supported */
      
            enum {                                              /* GRANULARITY_ODT_ENTRY_SIZE_STIM */
              "GRANULARITY_ODT_ENTRY_SIZE_STIM_BYTE"   = 1,
              "GRANULARITY_ODT_ENTRY_SIZE_STIM_WORD"   = 2,
              "GRANULARITY_ODT_ENTRY_SIZE_STIM_DWORD"  = 4,
              "GRANULARITY_ODT_ENTRY_SIZE_STIM_DLONG"  = 8
            };
      
            uchar;                                              /* MAX_ODT_ENTRY_SIZE_STIM */
      
            taggedstruct {                                      /* bitwise stimulation */
              "BIT_STIM_SUPPORTED";
              "MIN_ST_STIM" uchar;                              /* separation time between DTOs */
                                                                /* time in units of 100 microseconds */
            };
          };
      
          block "TIMESTAMP_SUPPORTED" struct {
            uint;                                               /* TIMESTAMP_TICKS */
            enum {                                              /* TIMESTAMP_SIZE */
              "NO_TIME_STAMP" = 0,
              "SIZE_BYTE"     = 1,
              "SIZE_WORD"     = 2,
              "SIZE_DWORD"    = 4
            };
            enum {                                              /* RESOLUTION OF TIMESTAMP */
              "UNIT_1NS"   = 0,
              "UNIT_10NS"  = 1,
              "UNIT_100NS" = 2,
              "UNIT_1US"   = 3,
              "UNIT_10US"  = 4,
              "UNIT_100US" = 5,
              "UNIT_1MS"   = 6,
              "UNIT_10MS"  = 7,
              "UNIT_100MS" = 8,
              "UNIT_1S"    = 9,
              "UNIT_1PS"   = 10,
              "UNIT_10PS"  = 11,
              "UNIT_100PS" = 12
            };
            taggedstruct {
              "TIMESTAMP_FIXED";
            };
          };
      
          "PID_OFF_SUPPORTED";
      
                                                                /* Configuration Limits */
          "MAX_DAQ_TOTAL" uint;
          "MAX_ODT_TOTAL" uint;
          "MAX_ODT_DAQ_TOTAL" uint;
          "MAX_ODT_STIM_TOTAL" uint;
          "MAX_ODT_ENTRIES_TOTAL" uint;
          "MAX_ODT_ENTRIES_DAQ_TOTAL" uint;
          "MAX_ODT_ENTRIES_STIM_TOTAL" uint;
      
          "CPU_LOAD_MAX_TOTAL" float;
          "CORE_LOAD_MAX_TOTAL" float;                          /* max load of all cores */
      
          (block "CORE_LOAD_MAX" struct {
            uint;                                               /* CORE_NR: core reference number */
            float;                                              /* CORE_LOAD_MAX: max load of core(CORE_NR) */
          })*;
      
          block "DAQ_MEMORY_CONSUMPTION" struct {
            ulong;                                              /* DAQ_MEMORY_LIMIT: in Elements[AG] */
            uint;                                               /* DAQ_SIZE: number of elements[AG] per DAQ list */
            uint;                                               /* ODT_SIZE: number of elements[AG] per ODT */
            uint;                                               /* ODT_ENTRY_SIZE: number of elements[AG] per ODT_entry */
            uint;                                               /* ODT_DAQ_BUFFER_ELEMENT_SIZE: number of */
                                                                /* payload elements[AG]*factor = sizeof(send buffer)[AG] */
            uint;                                               /* ODT_STIM_BUFFER_ELEMENT_SIZE: number of */
                                                                /* payload elements[AG]*factor = sizeof(receive buffer)[AG] */
            taggedstruct {
              block "BUFFER_RESERVE" struct {                   /* default for all EVENTs */
                uchar;                                          /* ODT_DAQ_BUFFER_ELEMENT_RESERVE  in % of */
                                                                /* ODT_DAQ_BUFFER_ELEMENT_SIZE */
                uchar;                                          /* ODT_STIM_BUFFER_ELEMENT_RESERVE in % of */
                                                                /* ODT_STIM_BUFFER_ELEMENT_SIZE */
              };
            };
          };
      
      /******************* start of DAQ_LIST *********************/
      
          (block "DAQ_LIST" struct {                            /* DAQ_LIST */
                                                                /* multiple possible */
            uint;                                               /* DAQ_LIST_NUMBER */
            taggedstruct {                                      /* optional */
              "DAQ_LIST_TYPE" enum {
                "DAQ"      = 1,                                 /* DIRECTION = DAQ only */
                "STIM"     = 2,                                 /* DIRECTION = STIM only */
                "DAQ_STIM" = 3                                  /* both directions possible */
                                                                /* but not simultaneously */
              };
      
              "MAX_ODT"         uchar;                          /* MAX_ODT */
              "MAX_ODT_ENTRIES" uchar;                          /* MAX_ODT_ENTRIES */
      
              "FIRST_PID" uchar;                                /* FIRST_PID for this DAQ_LIST */
              "EVENT_FIXED" uint;                               /* this DAQ_LIST always */
                                                                /* in this event */
              "DAQ_PACKED_MODE_SUPPORTED";                      /* supports DAQ packed mode */
      
              block "PREDEFINED" taggedstruct {                 /* predefined */
                                                                /* not configurable DAQ_LIST */
                (block "ODT" struct {
                  uchar;                                        /* ODT number */
                  taggedstruct {
                    ("ODT_ENTRY" struct {
                      uchar;                                    /* ODT_ENTRY number */
                      ulong;                                    /* address of element */
                      uchar;                                    /* address extension of element */
                      uchar;                                    /* size of element [AG] */
                      uchar;                                    /* BIT_OFFSET */
                    })*;
                  };                                            /* end of ODT_ENTRY */
                })*;                                            /* end of ODT */
              };                                                /* end of PREDEFINED */
            };
          })*;
      
      /******************* end of DAQ_LIST ***********************/
      
      /******************* start of EVENT ************************/
      
          (block "EVENT" struct {                               /* EVENT */
                                                                /* multiple possible */
            char[101];                                          /* EVENT_CHANNEL_NAME */
            char[9];                                            /* EVENT_CHANNEL_SHORT_NAME */
            uint;                                               /* EVENT_CHANNEL_NUMBER */
      
            enum {
              "DAQ"      = 1,                                   /* only DAQ_LISTs */
                                                                /* with DIRECTION = DAQ */
              "STIM"     = 2,                                   /* only DAQ_LISTs */
                                                                /* with DIRECTION = STIM */
              "DAQ_STIM" = 3                                    /* both kind of DAQ_LISTs */
            };
      
            uchar;                                              /* MAX_DAQ_LIST */
            uchar;                                              /* EVENT_CHANNEL_TIME_CYCLE */
            uchar;                                              /* EVENT_CHANNEL_TIME_UNIT */
            uchar;                                              /* EVENT_CHANNEL_PRIORITY */
            taggedstruct {                                      /* optional */
      
              "COMPLEMENTARY_BYPASS_EVENT_CHANNEL_NUMBER" uint; /* for compatibility reasons */
                                                                /* not to be considered, if 1.3 Bypassing features are implemented */
              "CONSISTENCY" enum {
                "DAQ"   = 0,
                "EVENT" = 1,
                "ODT"   = 2,
                "NONE"  = 3
              };
      
              "EVENT_COUNTER_PRESENT";
              "RELATED_EVENT_CHANNEL_NUMBER" uint;
              "RELATED_EVENT_CHANNEL_NUMBER_FIXED";             /* RELATED_EVENT_CHANNEL_NUMBER can not be modified. */
              "DTO_CTR_DAQ_MODE" enum {                         /* When inserting the DTO CTR field: */
                "INSERT_COUNTER" = 0,                           /* - use CTR of the related event channel */
                "INSERT_STIM_COUNTER_COPY" = 1                  /* - use STIM CTR CPY of the related event channel */
              };
              "DTO_CTR_DAQ_MODE_FIXED";                         /* DTO_CTR_DAQ_MODE properties can not be modified. */
              "DTO_CTR_STIM_MODE" enum {                        /* When receiving DTOs with CTR field: */
                "DO_NOT_CHECK_COUNTER" = 0,                     /* - do not check CTR */
                "CHECK_COUNTER" = 1                             /* - check CTR */
              };
              "DTO_CTR_STIM_MODE_FIXED";                        /* DTO_CTR_STIM_MODE properties can not be modified */
              "STIM_DTO_CTR_COPY_PRESENT";                      /* DTO CTR can be saved for later reference */
      
              block "DAQ_PACKED_MODE" struct {                  /* DAQ packed mode, applies for all associated DAQ lists */
                enum {                                          /* El. A,B,C,D, 3 samples */
                  "ELEMENT_GROUPED" = 1,                        /* A0A1A2B0B1B2C0C1C2D0D1D2 */
                  "EVENT_GROUPED"   = 2                         /* A0B0C0D0A1B1C1D1A2B2C2D2 */
                };
      
                enum {                                          /* timestamp mode */
                  "STS_LAST"      = 0,                          /* single timestamp of last sample */
                  "STS_FIRST"     = 1                           /* single timestamp of first sample */
                };
      
                enum {                                          /* usage */
                  "OPTIONAL"      = 0,                          /* optional, EVENT allows also non-packed mode */
                  "MANDATORY"     = 1                           /* mandatory, only packed mode allowed */
                };
      
                uint;                                           /* DAQ packed mode sample count */
                taggedstruct {
                  ("ALT_SAMPLE_COUNT" uint)*;                   /* other valid sample count values (optional) */
                };
              };
      
              block "MIN_CYCLE_TIME" struct {                   /* Configuration with 0-0 not allowed */
                uchar;                                          /* EVENT_CHANNEL_TIME_CYCLE */
                uchar;                                          /* EVENT_CHANNEL_TIME_UNIT */
              };
              block "BUFFER_RESERVE_EVENT" struct {
                                                                /* overrules default BUFFER_RESERVE for this EVENT */
                uchar;                                          /* ODT_DAQ_BUFFER_ELEMENT_RESERVE  in % of ODT_DAQ_BUFFER_ELEMENT_SIZE */
                uchar;                                          /* ODT_STIM_BUFFER_ELEMENT_RESERVE in % of ODT_STIM_BUFFER_ELEMENT_SIZE */
              };
      
              "CPU_LOAD_MAX" float;
      
              block "CPU_LOAD_CONSUMPTION_DAQ" struct {
                float;                                          /* DAQ_FACTOR */
                float;                                          /* ODT_FACTOR */
                float;                                          /* ODT_ENTRY_FACTOR */
                taggedstruct {
                  (block "ODT_ENTRY_SIZE_FACTOR_TABLE" struct{
                    uint;                                       /* SIZE */
                    float;                                      /* SIZE_FACTOR */
                  })*;
                  block "CORE_LOAD_EP" struct {
                    uint;                                       /* CORE_NR: core reference number */
                    float;                                      /* CORE_LOAD_EP_MAX: max load of this event part */
                  };
                };
              };
      
              block "CPU_LOAD_CONSUMPTION_STIM" struct {
                float;                                          /* DAQ_FACTOR */
                float;                                          /* ODT_FACTOR */
                float;                                          /* ODT_ENTRY_FACTOR */
                taggedstruct {
                  (block "ODT_ENTRY_SIZE_FACTOR_TABLE" struct{
                    uint;                                       /* SIZE */
                    float;                                      /* SIZE_FACTOR */
                  })*;
                  block "CORE_LOAD_EP" struct {
                    uint;                                       /* CORE_NR: core reference number */
                    float;                                      /* CORE_LOAD_EP_MAX: max load of this event part */
                  };
                };
              };
      
              block "CPU_LOAD_CONSUMPTION_QUEUE" struct {
                                                                /* default for DAQ and STIM QUEUE */
                float;                                          /* ODT_FACTOR */
                float;                                          /* ODT_ELEMENT_LOAD: length in elements[AG] */
                taggedstruct {
                  block "CORE_LOAD_EP" struct {
                    uint;                                       /* CORE_NR: core reference number */
                    float;                                      /* CORE_LOAD_EP_MAX: max load of this event part */
                  };
                };
              };
      
              block "CPU_LOAD_CONSUMPTION_QUEUE_STIM" struct {
                                                                /* overrules CPU_LOAD_CONSUMPTION_QUEUE for STIM QUEUE */
                float;                                          /* ODT_FACTOR */
                float;                                          /* ODT_ELEMENT_LOAD: length in elements[AG] */
                taggedstruct {
                  block "CORE_LOAD_EP" struct {
                    uint;                                       /* CORE_NR: core reference number */
                    float;                                      /* CORE_LOAD_EP_MAX: max load of this event part */
                  };
                };
              };
            };
          })*;
      
      /********************* end of EVENT ************************/
      
        };                                                      /* end of optional at DAQ */
      
      };
      
      /********************* end of DAQ **************************/
      
      
      /***************** start of DAQ_EVENT **********************/
      
      taggedunion Daq_Event {                                   /* at MEASUREMENT */
        "FIXED_EVENT_LIST" taggedstruct {
          ("EVENT" uint)*;
        };
        "VARIABLE" taggedstruct {
          block "AVAILABLE_EVENT_LIST" taggedstruct {
            ("EVENT" uint)*;
          };
          block "DEFAULT_EVENT_LIST" taggedstruct {
            ("EVENT" uint)*;
          };
          block "CONSISTENCY_EVENT_LIST" taggedstruct {
            ("EVENT" uint)*;
          };
        };
      };
      
      /******************** end of DAQ_EVENT *********************/
      
      
      /********************** start of PAG ***********************/
      
      struct Pag {                                              /* PAG supported, at MODULE */
        uchar;                                                  /* MAX_SEGMENTS */
        taggedstruct {                                          /* optional */
          "FREEZE_SUPPORTED";
        };
      
      };
      
      /*********************** end of PAG ************************/
      
      
      /********************** start of PGM ***********************/
      
      struct Pgm {                                              /* PGM supported, at MODULE */
      
        enum {
          "PGM_MODE_ABSOLUTE"                = 1,
          "PGM_MODE_FUNCTIONAL"              = 2,
          "PGM_MODE_ABSOLUTE_AND_FUNCTIONAL" = 3
        };
        uchar;                                                  /* MAX_SECTORS */
        uchar;                                                  /* MAX_CTO_PGM */
      
        taggedstruct {                                          /* optional */
          (block "SECTOR" struct {                              /* SECTOR */
                                                                /* multiple possible */
            char[101];                                          /* SECTOR_NAME */
            uchar;                                              /* SECTOR_NUMBER */
            ulong;                                              /* Address */
            ulong;                                              /* Length */
            uchar;                                              /* CLEAR_SEQUENCE_NUMBER */
            uchar;                                              /* PROGRAM_SEQUENCE_NUMBER */
            uchar;                                              /* PROGRAM_METHOD */
          })*;                                                  /* end of SECTOR */
      
          "COMMUNICATION_MODE_SUPPORTED" taggedunion {          /* optional modes supported */
            "BLOCK" taggedstruct {
              "SLAVE";                                          /* Slave Block Mode supported */
              "MASTER" struct {                                 /* Master Block Mode supported */
                uchar;                                          /* MAX_BS_PGM */
                uchar;                                          /* MIN_ST_PGM */
              };
            };
            "INTERLEAVED" uchar;                                /* QUEUE_SIZE_PGM */
          };
        };
      };
      
      /*********************** end of PGM ************************/
      
      
      /******************** start of SEGMENT *********************/
      
      struct Segment {                                          /* at MEMORY_SEGMENT */
        uchar;                                                  /* SEGMENT_NUMBER */
        uchar;                                                  /* number of pages */
        uchar;                                                  /* ADDRESS_EXTENSION */
        uchar;                                                  /* COMPRESSION_METHOD */
        uchar;                                                  /* ENCRYPTION_METHOD */
      
        taggedstruct {                                          /* optional */
          block "CHECKSUM" struct {
            enum {                                              /* checksum type */
              "XCP_ADD_11"       =   1,
              "XCP_ADD_12"       =   2,
              "XCP_ADD_14"       =   3,
              "XCP_ADD_22"       =   4,
              "XCP_ADD_24"       =   5,
              "XCP_ADD_44"       =   6,
              "XCP_CRC_16"       =   7,
              "XCP_CRC_16_CITT"  =   8,
              "XCP_CRC_32"       =   9,
              "XCP_USER_DEFINED" = 255
            };
      
            taggedstruct {
              "MAX_BLOCK_SIZE" ulong;                           /* maximum block size */
                                                                /* for checksum calculation */
              "EXTERNAL_FUNCTION" char[256];                    /* Name of the Checksum function */
                                                                /* including file extension */
                                                                /* without path */
              "MTA_BLOCK_SIZE_ALIGN" uint;                      /* required alignment of MTA and block size */
            };
          };
      
          "DEFAULT_PAGE_NUMBER" uchar;                          /* Number of the default page */
      
          (block "PAGE" struct {                                /* PAGES for this SEGMENT */
                                                                /* multiple possible */
            uchar;                                              /* PAGE_NUMBER */
      
            enum {                                              /* ECU_ACCESS_TYPE */
              "ECU_ACCESS_NOT_ALLOWED"      = 0,
              "ECU_ACCESS_WITHOUT_XCP_ONLY" = 1,
              "ECU_ACCESS_WITH_XCP_ONLY"    = 2,
              "ECU_ACCESS_DONT_CARE"        = 3
            };
      
            enum {                                              /* XCP_READ_ACCESS_TYPE */
              "XCP_READ_ACCESS_NOT_ALLOWED"      = 0,
              "XCP_READ_ACCESS_WITHOUT_ECU_ONLY" = 1,
              "XCP_READ_ACCESS_WITH_ECU_ONLY"    = 2,
              "XCP_READ_ACCESS_DONT_CARE"        = 3
            };
      
            enum {                                              /* XCP_WRITE_ACCESS_TYPE */
              "XCP_WRITE_ACCESS_NOT_ALLOWED"      = 0,
              "XCP_WRITE_ACCESS_WITHOUT_ECU_ONLY" = 1,
              "XCP_WRITE_ACCESS_WITH_ECU_ONLY"    = 2,
              "XCP_WRITE_ACCESS_DONT_CARE"        = 3
            };
            taggedstruct {
              "INIT_SEGMENT" uchar;                             /* references segment that initialises this page */
            };
      
          })*;                                                  /* end of PAGE */
      
          (block "ADDRESS_MAPPING" struct {                     /* multiple possible */
            ulong;                                              /* source address */
            ulong;                                              /* destination address */
            ulong;                                              /* length */
          })*;
      
          "PGM_VERIFY" ulong;                                   /* verification value for PGM */
        };                                                      /* end of optional */
      
      };
      
      /********************** end of SEGMENT *********************/
      
      
      /***************** start of TIME_CORRELATION ***************/
      taggedstruct Time_Correlation {
      
      /***********************************************************/
      /*    XCP_SLAVE_CLOCK and ECU_CLOCK need not               */
      /*    necessarily be the same clock, i.e. in case of       */
      /*    an external XCP Slave, these clocks might differ     */
      /***********************************************************/
      
        "DAQ_TIMESTAMPS_RELATE_TO" enum {
          "XCP_SLAVE_CLOCK"           = 0,
          "ECU_CLOCK"                 = 1
        };
      
        (block "CLOCK" struct {
          char;                                                 /* globally unique clock identifier (UUID/EUI), 1st octet (most significant byte) */
          char;                                                 /* globally unique clock identifier (UUID/EUI), 2nd octet */
          char;                                                 /* globally unique clock identifier (UUID/EUI), 3rd octet */
          char;                                                 /* globally unique clock identifier (UUID/EUI), 4th octet */
          char;                                                 /* globally unique clock identifier (UUID/EUI), 5th octet */
          char;                                                 /* globally unique clock identifier (UUID/EUI), 6th octet */
          char;                                                 /* globally unique clock identifier (UUID/EUI), 7th octet */
          char;                                                 /* globally unique clock identifier (UUID/EUI), 8th octet (least significant byte) */
      
          enum {                                                /* clock enumerator */
            "XCP_SLAVE_CLOCK"             = 0,
            "ECU_CLOCK"                   = 1,
            "XCP_SLAVE_GRANDMASTER_CLOCK" = 2,                  /* related to XCP_SLAVE_CLOCK */
            "ECU_GRANDMASTER_CLOCK"       = 3                   /* related to ECU_CLOCK in case of an external slave */
          };
          enum {                                                /* readability */
            "RANDOMLY_READABLE" = 0,
            "LIMITED_READABLE"  = 1,
            "NOT_READABLE"      = 2
          };
          enum {                                                /* synchronization features */
            "SYN_UNSUPPORTED"      = 0,                         /* clock neither supports synchronization */
                                                                /* nor syntonization */
            "SYNCHRONIZATION_ONLY" = 1,                         /* clock only supports synchronization to */
                                                                /* external grandmaster clock */
            "SYNTONIZATION_ONLY"   = 2,                         /* clock only supports syntonization to */
                                                                /* external grandmaster clock */
            "SYN_ALL"              = 3                          /* clock supports synchronization as well */
                                                                /* as syntonization to external grandmaster clock */
          };
          uchar;                                                /* clock quality, stratum level */
      
          taggedstruct {
            block "TIMESTAMP_CHARACTERIZATION" struct {
              uint;                                             /* TIMESTAMP_TICKS */
              enum {                                            /* RESOLUTION OF TIMESTAMP */
                "UNIT_1NS"   = 0,
                "UNIT_10NS"  = 1,
                "UNIT_100NS" = 2,
                "UNIT_1US"   = 3,
                "UNIT_10US"  = 4,
                "UNIT_100US" = 5,
                "UNIT_1MS"   = 6,
                "UNIT_10MS"  = 7,
                "UNIT_100MS" = 8,
                "UNIT_1S"    = 9,
                "UNIT_1PS"   = 10,
                "UNIT_10PS"  = 11,
                "UNIT_100PS" = 12
              };
              enum {                                            /* NATIVE TIMESTAMP SIZE */
                "SIZE_FOUR_BYTE"  = 4,
                "SIZE_EIGHT_BYTE" = 8
              };
            };
          };
      
          uint64;                                               /* MAX_TIMESTAMP_VALUE_BEFORE_WRAP_AROUND */
          enum {                                                /* epoch */
            "ATOMIC_TIME"                = 0,                   /* TAI */
            "UNIVERSAL_COORDINATED_TIME" = 1,                   /* UTC */
            "ARBITRARY"                  = 2                    /* unknown */
          };
        })*;
      };
      /*****************  end of TIME_CORRELATION ****************/
      /***************** start of Common Parameters **************/
      
      taggedstruct Common_Parameters {
      
        block "PROTOCOL_LAYER" struct Protocol_Layer;
        block "TIME_CORRELATION" taggedstruct Time_Correlation;
      
        block "SEGMENT" struct Segment;
      
        block "DAQ" struct Daq;
        block "PAG" struct Pag;
        block "PGM" struct Pgm;
      
        block "DAQ_EVENT" taggedunion Daq_Event;
      
      };
      
      /****************** end of Common Parameters ***************/
      
      /***********************************************************/
      /*                                                         */
      /*   ASAP2 meta language for XCP on UDP_IP V1.4            */
      /*                                                         */
      /*                                                         */
      /*   Datatypes:                                            */
      /*                                                         */
      /*   A2ML       description                                */
      /*   ---------------------------------------------------   */
      /*   uchar      unsigned 8 Bit                             */
      /*   char       signed 8 Bit                               */
      /*   uint       unsigned integer 16 Bit                    */
      /*   int        signed integer 16 Bit                      */
      /*   ulong      unsigned integer 32 Bit                    */
      /*   long       signed integer 32 Bit                      */
      /*   int64      signed integer 64 Bit                      */
      /*   uint64     unsigned integer 64 Bit                    */
      /*   float      float point 32 Bit IEEE 754                */
      /*   double     float point 64 Bit IEEE 754                */
      /*                                                         */
      /***********************************************************/
      
      /************************ start of UDP_IP ******************/
      
      struct UDP_IP_Parameters {
      
        uint;                          /* XCP on UDP_IP version */
                                       /* "1.4" = 0x0104 */
        uint;                          /* PORT */
      
        taggedunion {
          "HOST_NAME" char[256];
          "ADDRESS" char[15];
          "IPV6" char[39];
        };
        taggedstruct{
          "MAX_BUS_LOAD"  ulong;       /* maximum available bus */
                                       /* load in percent */
          "MAX_BIT_RATE"  ulong;       /* Network speed which is */
                                       /* the base for MAX_BUS_LOAD in Mbit */
        };
      
        taggedstruct{
          "PACKET_ALIGNMENT" enum {
            "PACKET_ALIGNMENT_8"  = 0, /* This is the default if the keyword is missing */
            "PACKET_ALIGNMENT_16" = 1,
            "PACKET_ALIGNMENT_32" = 2
          };
        };
      
        taggedstruct{
          ("OPTIONAL_TL_SUBCMD" enum { /* XCP-Code of optional transport layer */
                                       /* specific subcommand supported by the slave */
            "GET_SLAVE_ID"             = 0xFF,
            "GET_SLAVE_ID_EXTENDED"    = 0xFD,
            "SET_SLAVE_IP_ADDRESS"     = 0xFC,
            "GET_DAQ_CLOCK_MULTICAST"  = 0xFA
          })*;
        };
      };
      
      /*************************** end of UDP_IP *****************/
      /************************************************************************************/ 
      /*                                                                                  */ 
      /*   ASAP2 meta language for IF_DATA XCP V1.0                                       */ 
      /*                                                                                  */ 
      /*   2003-03-03                                                                     */ 
      /*                                                                                  */ 
      /*   Vector Informatik, Schuermans                                                  */ 
      /*                                                                                  */ 
      /*   Datatypes:                                                                     */ 
      /*                                                                                  */ 
      /*   A2ML       ASAP2             Windows      description                          */ 
      /*   -------------------------------------------------------------------------------*/ 
      /*   uchar      UBYTE             BYTE         unsigned 8 Bit                       */ 
      /*   char       SBYTE             char         signed 8 Bit                         */ 
      /*   uint       UWORD             WORD         unsigned integer 16 Bit              */ 
      /*   int        SWORD             int          signed integer 16 Bit                */ 
      /*   ulong      ULONG             DWORD        unsigned integer 32 Bit              */ 
      /*   long       SLONG             LONG         signed integer 32 Bit                */ 
      /*   float      FLOAT32_IEEE      float        32 Bit                               */ 
      /*                                                                                  */ 
      /************************************************************************************/ 
      
      /************ start of XCP on different Transport Layers ******************/
      
      struct XCP { 
        taggedstruct Common_Parameters ;
        taggedstruct {
          block "XCP_ON_UDP_IP" struct { 
            struct UDP_IP_Parameters ;
            taggedstruct Common_Parameters;
          }; 
        }; 
      };/************ end of XCP on different Transport Layers ******************/
      
      /***********************************************************/
      /*                                                         */
      /*   ASAP2 meta language for XCPplus V1.3                  */
      /*                                                         */
      /*                                                         */
      /*   Datatypes:                                            */
      /*                                                         */
      /*   A2ML       description                                */
      /*   ---------------------------------------------------   */
      /*   uchar      unsigned 8 Bit                             */
      /*   char       signed 8 Bit                               */
      /*   uint       unsigned integer 16 Bit                    */
      /*   int        signed integer 16 Bit                      */
      /*   ulong      unsigned integer 32 Bit                    */
      /*   long       signed integer 32 Bit                      */
      /*   int64      signed integer 64 Bit                      */
      /*   uint64     unsigned integer 64 Bit                    */
      /*   float      float point 32 Bit IEEE 754                */
      /*   double     float point 64 Bit IEEE 754                */
      /*                                                         */
      /***********************************************************/
      
      /******** start of XCP on different Transport Layers *******/
      
      struct XCPplus {
        uint;
        taggedstruct Common_Parameters ;    /* default parameters */
      
        taggedstruct {                      /* transport layer specific parameters */
                                            /* overruling of the default parameters */
      
          (block "XCP_ON_UDP_IP" struct {
      
            struct UDP_IP_Parameters ;      /* specific for UDP */
            taggedstruct Common_Parameters; /* overruling of default */
            taggedstruct {
              "TRANSPORT_LAYER_INSTANCE" char[101];
            };
      
          })*;
      
        };
      
      };
      
      /******** end of XCP on different Transport Layers *********/
      
      /*******************************************************************/
      /* CSM_X07 V12     (C) 2013-2020 CSM GmbH, Filderstadt, Germany    */
      /*                                                                 */
      /* ASAP2 meta language for CSMConfig.                              */
      /*                                                                 */
      /* Datatypes:                                                      */
      /* A2ML   ASAP2         Windows       description                  */
      /* --------------------------------------------------------------- */
      /* uchar  UBYTE         BYTE          unsigned 8 Bit               */
      /* char   SBYTE         char          signed 8 Bit                 */
      /* uint   UWORD         WORD          unsigned integer 16 Bit      */
      /* int    SWORD         int           signed integer 16 Bit        */
      /* ulong  ULONG         DWORD         unsigned integer 32 Bit      */
      /* long   SLONG         LONG          signed integer 32 Bit        */
      /*    Don't use int64, because it's not supported by ASAP2 V1.6.1  */
      /*    uint64 A_UINT64      UINT64        unsigned integer 64 Bit   */
      /*    int64  A_INT64       __int64       signed integer 64 Bit     */
      /* float  FLOAT64_IEEE  double        IEEE floating point 64 Bit   */
      /*                                                                 */
      /*******************************************************************/
      
      /* Module internal adjustment parameters */
      struct CSM_ADJUSTMENT_PARAMS {
        float;                                /* Gain */
        float;                                /* Offset */
      };
      
      /* CAN Bus settings */
      struct CSM_BUSCAN {
        enum { 
          "CAN_11BIT" = 11 ,                  /* CAN 2.0A Base frame format */
          "CAN_29BIT" = 29                    /* CAN 2.0B Extended frame format */
        };                                    /* CAN frame type */
        ulong;                                /* bitrate */
        uint;                                 /* samplepoint */
        uint;                                 /* mode */
        char[256];                            /* canDBPath */
        uint;                                 /* canDBMode */  
      };
      
      /* An arbitrary measurement bus */
      struct CSM_BUS {
        char[255];                            /* Name */
        uint;                                 /* Flags */
        taggedstruct {
          "BUS_ETHERCAT";                     /* EtherCAT bus */
          "BUS_CAN" struct CSM_BUSCAN;        /* CAN bus */
          "BUS_XCPONUDPIP";                   /* XCP on UDP/IP between host and XCP gateway */
        };                                    /* Type of the bus */
        taggedstruct {
          block "LONG_DESCRIPTION" ( char[512] )*;
        };
      };
      
      /* A comment string */
      struct CSM_COMMENT {
        char[100];                            /* Comment: see tDevice.comment */
      };
      
      /* Generic channel settings about physical range */
      struct CSM_DISPSCALE {
        char[32];                             /* phys. unit, see tChannel.unit */
        float;                                /* Display minimum */
        float;                                /* Display maximum */
      };
      
      /* ECM_CONFIG : ECM device settings */
      struct CSM_ECMCONFIG {
        float;                                /* alphaP */
        float;                                /* alphaP1 */
        float;                                /* alphaNOx */
        float;                                /* fcHC */
        float;                                /* fcOC */
        float;                                /* fcNC */
        uint;                                 /* modeH2 */
        uint;                                 /* modePressComp */
        enum {                                /* operationMode */
          "ECM_MODE_UNSPECIFIC" = 0,          /* unspecific mode */
          "ECM_MODE_ECM" = 1,                 /* regular ECM mode */
          "ECM_MODE_CSM" = 2                  /* LambaCANc in CSM mode */
        };
        uint;                                 /* sensorSelected */
        uint;                                 /* sensorConnected */
        uint;                                 /* sensorLineType */
        uint;                                 /* heaterLineType */
      };
      
      /* ECM_DELTAENTRY */
      struct CSM_ECMDELTAENTRY {
        int;                                  /* X */
        int;                                  /* related delta */
      };
      
      /* ECM_DELTATABLE */
      struct CSM_ECMDELTATABLE {
        taggedstruct {
          ( "ECM_DELTAENTRY" struct CSM_ECMDELTAENTRY )*;
        };
      };
      
      /* ECM_HEATERENTRY */
      struct CSM_ECMHEATERENTRY {
        uchar;                                /* V : single heater line point (n*100mV) */
      };
      
      /* ECM_HEATERLINE */
      struct CSM_ECMHEATERLINE {
        char[255];                            /* name : file name */
        taggedstruct {
          ( "ECM_HEATERENTRY" struct CSM_ECMHEATERENTRY )*;
        };
      };
      
      /* ECM_SENSORENTRY */
      struct CSM_ECMSENSORENTRY {
        int;                                  /* ip : */
        int;                                  /* ox : Oxygen */
        int;                                  /* la : Lambda */
      };
      
      /* ECM: keep all the data from a sensor line file */
      struct CSM_ECMSENSORLINE {
        char[255];                            /* name : file name */
        uint;                                 /* rpvs (ohm) */
        taggedstruct {
          ( "ECM_SENSORENTRY" struct CSM_ECMSENSORENTRY )*;
        };
      };
      
      /* ECM txMode : Enhanced settings when ECM LambdaCANc sends 16-bit measurement values. */
      struct CSM_ECMTXMODE {
        enum {                                /* txMode */
          "ECMTX32BIT" = 1,                   /* only 32 bit */
          "ECMTX16BIT" = 2,                   /* only 16 bit */
          "ECMTXMIXED" = 3                    /* 32 and 16 bit */
        };
        ulong;                                /* base16ID  */
      };
      
      /* ECM: LambaCANc or NOxCAN in ECM mode */
      struct CSM_ECMMODEECM {
        taggedstruct {
          block "ECM_DELTAO2" struct CSM_ECMDELTATABLE;
          block "ECM_DELTALAMBDA" struct CSM_ECMDELTATABLE;
        };
      };
      
      /* ECM: LambdaCANc in CSM mode */
      struct CSM_ECMMODECSM {
        taggedstruct {
          block "ECM_SENSORLINE" struct CSM_ECMSENSORLINE;
          block "ECM_HEATERLINE" struct CSM_ECMHEATERLINE;
          "ECM_TXMODE" struct CSM_ECMTXMODE;
        };
      };
      
      /* ECM: channel specific data */
      struct CSM_ECMPARAMS {                  
        uint;                                 /* function: OID */
      };
      
      /* Parameters for linear conversion */
      struct CSM_LINSCALE {
        float;                                /* Factor */
        float;                                /* Offset */
      };
      
      /* Settings for a PTMM channel */
      struct CSM_PTMM {
        enum {                                /* PT sensor type */
          "PT100" = 0,
          "PT1000" = 1
        };
        enum {                                /* PT range */
          "PT_NORMAL" = 0,
          "PT_EXTENDED" = 1,
          "PT_FINE" = 2
        };
        ulong;                                /* Coeff. R0 */
        float;                                /* Coeff. A */
        float;                                /* Coeff. B */
        float;                                /* Coeff. C */
        ulong;                                /* IDnum */
        char[5];                              /* IDtext */
      };
      
      /* Collects all parameters for one OUTMM channel */
      struct CSM_OUTMMPARAMS {
        uchar;                                /* OutType:     Output type for this channel */
        uchar;                                /* HighLevel:   Output level in V (5/8/10/12/15) */
        uchar;                                /* Load:        Load settings */
                                              /* Msg: OUTMM_OUTFREQ */
        uint;                                 /* Frequency:   Output frequency. 0..10000 * 0.1/1/10 (see eOUTMMType) */
        uchar;                                /* Duty:        Duty cycle, 0..100 % */
                                              /* Msg: OUTMM_LIMITS */
        uint;                                 /* Default:     Raw Value for output default (result depends on OutType) */
        uint;                                 /* LimitMin:    Raw Value for output lower limit () */
        uint;                                 /* LimitMax:    Raw Value for output upper limit () */
                                              /* Msg: OUTMM_SIGNALMSG */
        ulong;                                /* SignalID:    CAN-ID of the trigger signal for this channel */
        uint;                                 /* TimeOut:     TMO for setting to default output value [ms] */
                                              /* Msg: OUTMM_SIGNALPOS */
        uchar;                                /* BitPosition: Bit position of trigger signal in its CAN message */
        uchar;                                /* BitLength:   Bit length of trigger signal */
        uchar;                                /* BitFormat:   Signed/Unsigned (bit7==1 -> signed), INTEL/MOT (Bit6==1 -> MOT) */
                                              /* Msg: OUTMM_CONV1 */
        ulong;                                /* SignalValue1:    Scaling: Signal value for first point */
        uint;                                 /* OutValue1:       Scaling: Raw output value first point */
                                              /* Msg: OUTMM_CONV2 */
        ulong;                                /* SignalValue2:    Scaling: Signal value for 2nd point */
        uint;                                 /* OutValue2:       Scaling: Raw output value 2nd point */
      };
      
      /* Holds all channel related data that is NOT part of the module configuration (-> DBC-Data). */
      struct CSM_OUTMMDBCDATA {
        char[32];                             /* Name:            Channel name handling as with CChannel.name */
          
                                              /* the controlling signal for this channel / Unit == Signal unit */
        float;                                /* SignalValue1:    Signal lower value (for 2points scaling) */
        float;                                /* SignalValue2:    Signal upper value / Unit = Channel Unit */
        float;                                /* SigFactor:       Scaling Factor for signal (from DBC), !NOT! normalized for OUTMM (difference to m_Channel::factor) */
        float;                                /* SigOffset:       Scaling Offset for signal (from DBC), !NOT! normalized for OUTMM (difference to m_Channel::factor) */
        char[16];                             /* SignalUnit:      Physical unit for the controlling signal (from DBC) */
          
                                              /* DBC references */
        char[32];                             /* DBCDBName:       DBC database name */
        char[32];                             /* DBCMsgName:      Message name from DBC */
        char[32];                             /* DBCSignalName:   Signal name from DBC */
      
                                              /*/ OUTMM output / Unit --> according to OUTMM channel function */
        ulong;                                /* OutFrequency:    OUTMM output freq. for PWM/Frequency 0..100kHz */
        float;                                /* OutValue1:       OUTMM output lower value (for 2points scaling) */
        float;                                /* OutValue2:       output upper value / Unit refers to channel function */
        float;                                /* OutDefault:      OUTMM output default value on no signal received */
        float;                                /* LimitMin:        OUTMM lower limit / Unit refers to channel function */
        float;                                /* LimitMax:        OUTMM upper limit / Unit refers to channel function */
        char[16];                             /* OutUnit:         OUTMM output physical unit (depends on channel type/function) */
      };
      
      struct CSM_SENSOR_DATA {
        taggedstruct {
          "TEDS_ID" struct {
            long;                             /* manufacturer ID (Basic TEDS) */
            long;                             /* modelNumber (Basic TEDS) */
            long;                             /* serial number (Basic TEDS) */
          };
          "CALIB_INFO" struct {
            char[12];                         /* calibDate (ISO 8601), tmpl.30/35 */
            uint;                             /* calibPeriod (tmpl.30/35) */
            char[32];                         /* calibInitials (tmpl.30/35) */
          };
        };
      };
      
      struct CSM_SENSOR_NAME {                /* sensor data base */
        char[255];                            /* name of the sensor type / probe */
      };
      
      /* Excitation voltage */
      struct CSM_SENSSUPPLY {
        float;                                /* Excitation voltage */
      };
      
      /* STG: strain gauge parameters */
      struct CSM_STG {
        enum {                                /* BridgeType */
          "QUARTER",                          /*  0=Quarter bridge */	
          "DIAGONAL",                         /*  1=Diagonal bridge */
          "HALF",                             /*  2=Half bridge */
          "HALF_TRANSVERSE",                  /*  3=Half bridge with transverse STG */
          "FULL",                             /*  4=Full bridge */
          "FULL_TRANSVERSE",                  /*  5=Full bridge with transverse STGs */
          "QUARTER_FREE",                     /*  6=Free entry with quarter bridge completion */
          "HALF_FREE",                        /*  7=Free entry with half bridge completion */
          "FULL_FREE",                        /*  8=Free entry without bridge completion */
          "CSM_QUARTER"                       /*  9=CSM quarter bridge completion */
        };
        float;                                /* kFactor */
        float;                                /* BridgeFactor */
        float;                                /* PoissonsRatio */
        uint;                                 /* Resistance */
        ulong;                                /* Factor16 */
      };
      
      /* TEDScontrol: basic information about the TEDS */
      struct CSM_TEDSCONTROL {
        uint;                                 /* valid */
        uint;                                 /* connected */
        ulong;                                /* hash value */
      };
      
      /* TEDSdata: raw data from the TEDS chip */
      struct CSM_TEDSDATA {
        uchar;                                /* chipID */
        uint;                                 /* chipSize */
        char[20];                             /* chipSN (int64 as string) */
        enum {                                /* verificationMode */
          "NO_CHECK",                         /*   0=no check of the connected sensor */
          "FAST_CHECK",                       /*   1=fast check: compare the chip S/N */
          "FULL_CHECK"                        /*   2=full check: compare the hash value of the TEDS (or the whole content) */
        };
        char[24];                             /* timestamp (ISO8601 as string: YYYY-MM-DDThh:mm:ss+TZTZ */
        taggedstruct {
          ( "TEDSpage" struct {               /* raw content of the TEDS chip, per TEDS page */
              uint;                           /*  page number */
              uint;                           /*  page size */
              uchar[32];                      /*  data bytes */
          } )*;
        };
      };
      
      /* TRANSMIT: Transfer rate and transfer properties for a channel (or the whole device). */
      struct CSM_TRANSMIT {
        ulong;                                /* Data transmission rate (raw value, NOT necessarily in ms!) */
        ulong;                                /* CAN ID of a channel in single channel mode. */
        uchar;                                /* Offset of the data bytes of a channel in between a CAN message (in single channel mode) */
        enum {                                /* CAN frame type */
          "CAN_11BIT" = 11 ,                  /* CAN 2.0A Base frame format */
          "CAN_29BIT" = 29                    /* CAN 2.0B Extended frame format */
        };
      };
      
      /* ZMODE: zero compenstation mode of STGMM */
      struct CSM_ZMODE {
        enum {                                /* compenstation mode */
          "MANUAL",                           /*   0=user defined offset */
          "POWERUP"                           /*   1=offset on power up */
        };
        long;                                 /* User defined offset */
      };
      
      /* CSM Measurement channel */
      struct CSM_CHANNEL { 
        char[255];                            /* ChannelRef */
        char[255];                            /* DeviceRef */
        uint;                                 /* ChannelNo */
        uint;                                 /* Flags */
        float;                                /* Range */
        uint;                                 /* Unit */
                                              /*  -- ADMM: ------- */
                                              /*  "UNIT_100MV" = 0 */
                                              /*  "UNIT_1MA"   = 1 */
                                              /*  "UNIT_100UV" = 2 */
                                              /*  "UNIT_1MV"   = 3 */
                                              /*  -- STGMM: ------ */
                                              /*  "UNIT_MV_V"  = 0 */
                                              /*  "UNIT_UM_M"  = 1 */
        enum {
          "UNIPOLAR",
          "BIPOLAR"
        };                                    /* Format */
        taggedstruct {                        /* optional */
          "ADJUSTMENT_PARAMS"                 /* modul internal adjustment */
            struct CSM_ADJUSTMENT_PARAMS;
          "CAL" struct {                      /* Auto-Offset/Scale wizzard */
            enum {                            /* CalType */
              "CAL_NONE" = 0,
              "CAL_OFFSET" = 1,
              "CAL_TWOPOINT" = 2
            };
            float;                            /* CalX0 */
            float;                            /* CalX1 */
          };
          "CNTA" struct {                     /* CNTMM channel settings */
              uint;                           /* Function */
              uint;                           /* BParam1 */
              uint;                           /* WParam1 */
              uint;                           /* WParam2 */
              uint;                           /* Sens */
              int;                            /* ThrshUp */
              int;                            /* ThrshDn */
              uint;                           /* Filter */
              uint;                           /* storeValue: store/reset current counter state */
              uint;                           /* auxResetMode: Quadrature counter reset channel */
          };
          "CSM_COMMENT" struct CSM_COMMENT;   /* channel comment */
          "DISPSCALE" struct CSM_DISPSCALE;   /* physical range settings */
          "ECM_PARAMS" struct CSM_ECMPARAMS;  /* ECM specific channel settings */
          "FILTER" struct {
            uint;                             /* FltType */
            ulong;                            /* FltFreq */
          };                                  /* Filter settings */
          "INTERNAL_ADJUST" struct {          /* extended settings for modul internal adjustment */
            uint;                             /* adjustment reference: 0=internal, 1=measured */
          };
          "INVERT";                           /* Invert measurement result */
          "LINSCALE" struct CSM_LINSCALE;     /* linear conversion parameters */
          "MESH_NUMBER" struct {
            uint;                             /* MeshNumber */
          };                                  /* MESH settings */
          "MSP" struct {
            int;                              /* MSP Number */
          };                                  /* MSP settings */
          "OUTMMDBCDATA" struct CSM_OUTMMDBCDATA;
          "OUTMMPARAMS" struct CSM_OUTMMPARAMS;
          "PTMM" struct CSM_PTMM;             /* PTMM channel settings */
          "SENSSUPPLY" struct CSM_SENSSUPPLY; /* Excitation settings */
          block "SENSOR_DATA" struct CSM_SENSOR_DATA; /* meta info from TEDS templates */
          "SENSOR_NAME" struct CSM_SENSOR_NAME;   /* sensor data base */
          "STG" struct CSM_STG;               /* strain gauge settings */
          "TEDScontrol" struct CSM_TEDSCONTROL;   /* TEDS hash */
          block "TEDSdata" struct CSM_TEDSDATA;   /* TEDS content */
          "TPSCALE" struct {
            float;                            /* X0 */
            float;                            /* Y0 */
            float;                            /* X1 */
            float;                            /* Y1 */
          };                                  /* Two point scaling */
          "TRANSMIT" struct CSM_TRANSMIT;     /* Transfer rate and transfer properties */
          "ZCMP" struct {
            enum {
              "OFF" = 0,                      /* inactive */
              /* "ON" = 1,                       active */
              "MSG" = 1,                      /* by CAN message */
              "MASK" = 2                      /* by bit masks in CAN message */
             };                               /* CompMode */
             ulong;                           /* CompID */
          };                                  /* Internal zero compensation */
          "ZMODE" struct CSM_ZMODE;           /* Internal zero compensation for STGMM */
        };
      };
      
      /* CSM MiniModule: CAN settings */
      struct CSM_CANDEVPARAM {
        ulong;                                /* CAN base id */
        ulong;                                /* CAN idstep */
        ulong;                                /* CAN idincr */
        enum { 
          "CAN_11BIT" = 11 ,                  /* CAN 2.0A Base frame format */
          "CAN_29BIT" = 29                    /* CAN 2.0B Extended frame format */
        };                                    /* CAN frame type */
        uint;                                 /* InfoMsg: boolean */
      };
      
      /* CSMpressure : CANopen Identity Record */
      struct CSM_CANOPENIDENTITY {
        ulong;                                /* Vendor-ID */
        ulong;                                /* Product code */
        ulong;                                /* Revision number */
        ulong;                                /* Serial number */
      };
      
      /* HV-BM specific data */
      struct CSM_HVBM {
        uint;                                 /* Shunt type */
        uchar;                                /* Channel mode (std, swap U/I) */
        uint;                                 /* HV BM 1.2 +S: shield shunt active */
        uint;                                 /* HV BM 1.2 +S: shield shunt type */
      };
      
      /* CSM Mesh table point */
      struct CSM_MESHENTRY {
        float;                                /* Sense */
        float;                                /* Phys */
        ulong;                                /* Input */
        uint;                                 /* Output */
      };
      
      /* CSM Mesh table */
      struct CSM_MESHTABLE {
          uint;                               /* Number */
          char[255];                          /* Name */
          uint;                               /* NumberOfEntries */
          enum {                              /* Domain of signal values */
            "VOLTAGE" = 0,
            "FREQUENCY" = 1,
            "TIMESPAN" = 2,
            "DUTY" = 3
          };
          taggedstruct {                      /* 0..* */
            ( "MESH_ENTRY" struct CSM_MESHENTRY )*;
          };
      };
      
      /* CSM Mesh tables (all of a device) */
      struct CSM_MESHTABLES {
        uint;                                 /* Version */
        taggedstruct {
          ( block "MESH_TAB" struct CSM_MESHTABLE )*;
        };
      };
      
      /* CSM MiniModule: properties of a particular device */
      struct CSM_DEVICEPROPS {
        ulong;                                /* HWrev */
        ulong;                                /* Version (FWver) */
        ulong;                                /* Capabilities */
        uint;                                 /* SpecialProps */
        ulong;                                /* ExtendedFeatures */
      };
      
      /* CSM MiniModule */
      struct CSM_DEVICE {
        char[255];                            /* Name */
        char[1024];                           /* LongIdentifier */
        char[255];                            /* BusRef */
        ulong;                                /* SerNr */
        char[255];                            /* SNExt */
        uint;                                 /* Type */
        uint;                                 /* Variant */
        uint;                                 /* Flags */
        uint;                                 /* NChannels */
        ulong;                                /* Rate */
        taggedstruct {                        /* optional */
          "BYTE_ORDER" enum {
            "MSB_FIRST" = 1,                  /* Motorola */
            "MSB_LAST" = 0                    /* Intel */
           };                                 /* Binary data format */
          "CANDEVPARAM" struct CSM_CANDEVPARAM;       /* CAN settings */
          "CANOPENIDENTITY" struct CSM_CANOPENIDENTITY;   /* CANopen Identity Record */
          "CONFIGHASH" struct {
            ulong;                                    /* Hash value */
          };
          "DEVICEPROPS" struct CSM_DEVICEPROPS;       /* Device properties */
          "ECM_CONFIG" struct CSM_ECMCONFIG;          /* ECM device settings */
          block "ECM_MODE_ECM" struct CSM_ECMMODEECM; /* ECM extension ECM mode */
          block "ECM_MODE_CSM" struct CSM_ECMMODECSM; /* ECM extension CSM mode */
          "HVBM" struct CSM_HVBM;                     /* HV-BM specific data */
          "PER_CHANNEL_CONFIG";                       /* Tag is set, if per-channel-config is active */
          "RESOLUTION" enum {                         /* Resolution of TH channels */
            "TH_0_1C" = 0,                            /* 0.1 C */
            "TH_1_0C" = 1,                            /* 1.0 C */
            "TH_16BIT" = 2                            /* 16 bit */
          };
          "SENSSUPPLY" struct CSM_SENSSUPPLY;         /* Excitation settings */
          block "MESH_TABLES" struct CSM_MESHTABLES;  /* Mesh tables */
          "OPERATION_MODE" enum {
            "NORMAL" = 0,                             /* STG normal operation */
            "REF_CHANNEL" = 1                         /* Reference channel mode */
           };                             
        };
      };
      
      /* XCP-Gateway: Synchronization Event Configuration */
      struct CSM_SYNCHRONIZATION_EVENT_CONFIGURATION {
          uchar;                              /* Timestamp format, allowed values:  0x20 = 32-Bit, 0x40 = 64-Bit       */ 
          uchar;                              /* Send synchronization byte, allowed values: 0x00 = false, 0x01 = true */
      };
        
      /* XCP-Gateway: Precision Time Protocol (IEEE 1588) Configuration */
      struct CSM_PRECISION_TIME_PROTOCOL_CONFIGURATION {
          uchar;                              /* PTP enabled/disabled [0..1]  */ 
          uchar;                              /* PTP Domain [1..255]          */
          char;                               /* PTP Runtime Interval [-4..6] */
          uchar;                              /* PTP Announce Time Out [0..48] */  
          taggedstruct {                      /* optional */
              "FLAGS" uchar;                  /* PTP FLags (Delay mechanism, ... ) */
          };
      };
      
      /* XCP-Gateway: Precision Time Protocol, additional information */
      struct CSM_PRECISION_TIME_PROTOCOL_INFO {
          uint;                               /* offset2Master: 2 byte reserved for offset to master (65535 == not available) */
          uint;                               /* meanPathDelay: delay value between slave and master clock (65535 == not available) */
          uchar;                              /* is_synchronized: is slave clock fully synchronized to GM clock */
          ulong;                              /* ptpTime: 32 bit timestamp in seconds (unix time) */
          uchar;                              /* delayMechanism: mechanism of measuring mean path delay */
          uchar[8];                           /* ownUUID[8]: UUID of local slave clock */
          uchar[8];                           /* grandMasterUUID[8]: UUID of selected grandmaster */
          uchar;                              /* gmPrio1: Priority 1 of selected grandmaster clock */
          uchar;                              /* gmClass: Class of selected grandmaster clock */
          uchar;                              /* gmAccuracy: Accuracy of selected grandmaster clock */
          uint;                               /* gmVariance: Variance of selected grandmaster clock */
          uchar;                              /* gmPrio2: Priority 2 of selected grandmaster clock */
          uchar;                              /* gmUTCOffset: UTC Offset in seconds of selected grandmasters' clock */
          uchar;                              /* gmTimeSource: Time source of selected grandmaster clock */
      };
      
      /* XCP-Gateway: GPS configuration */
      struct CSM_GPS_CONFIGURATION {
          uchar;                              /* GPS-Sync enabled/disabled [0..1]  */ 
      };
      
      /* CSM XCP-Gateway */
      struct CSM_GATEWAY {
        char[16];                             /* SubNetMask */
        taggedstruct {                        /* optional */
          "SNO" uint;                         /* SerNr of the XCP Gateway */
          "MULTIECAT" struct {
            enum {
              "MULTIECAT_10KHZ" = 0,
              "MULTIECAT_2KHZ" = 1
            };
          };
          "SYNC_EVT_CFG" struct CSM_SYNCHRONIZATION_EVENT_CONFIGURATION; 
          "PTP_CFG" struct CSM_PRECISION_TIME_PROTOCOL_CONFIGURATION; 
          block "PTP_INFO" struct CSM_PRECISION_TIME_PROTOCOL_INFO;
          "GPS_CFG" struct CSM_GPS_CONFIGURATION;
        };
      };
      
      /* CSM global settings */
      struct CSM_SETTINGS {
        taggedstruct {
          "MASTER_ID" struct {
            ulong;                            /* Master-ID */
          };
        };
      };
      
      /* CSM ASAP2 extension */
      struct CSM_X07 {
        uint;                                 /* A2L version number */
        taggedstruct {
          block "GATEWAY" struct CSM_GATEWAY;         /* XCP-Gateway */
          ( block "BUS" struct CSM_BUS )*;            /* Measurement Bus */
          ( block "DEVICE" struct CSM_DEVICE )*;      /* CSM MiniModule */
          ( block "CHANNEL" struct CSM_CHANNEL )*;    /* CSM Channel */
          ( block "SETTINGS" struct CSM_SETTINGS )*;  /* CSM global settings */
        };
      };
      
      /* Combine the IF_DATA extensions */
      block "IF_DATA" taggedunion {
        "XCP" struct XCP;
        "XCPplus" struct XCPplus;
        "CSM_X01" struct CSM_X07;
        "CSM_X02" struct CSM_X07;
        "CSM_X03" struct CSM_X07;
        "CSM_X04" struct CSM_X07;
        "CSM_X05" struct CSM_X07;
        "CSM_X06" struct CSM_X07;
        "CSM_X07" struct CSM_X07;
      };
    /end A2ML
    
    /begin MOD_PAR ""
      VERSION "8.14.0.9368"
      USER "visza"
      ECU "XCP-Gateway"
      CPU_TYPE "Xilinx Spartan 3"
    /end MOD_PAR
    
    /begin IF_DATA XCPplus 0x0104
      /begin PROTOCOL_LAYER
        0x0104                                 /* XCP protocol layer version: 1.4 */
        10000                                  /* T1 = 10000ms = 10.0s */
        1000                                   /* T2 =  1000ms =  1.0s */
        0x00                                   /* T3 =     0ms */
        0x00                                   /* T4 =     0ms */
        0x00                                   /* T5 =     0ms */
        0x00                                   /* T6 =     0ms */
        0x00                                   /* T7 =     0ms */
        0xFF                                   /* MAX_CTO =  255 */
        0x05BC                                 /* MAX_DTO =  1468 */
        BYTE_ORDER_MSB_LAST                    /* BIG_ENDIAN = Intel */
        ADDRESS_GRANULARITY_BYTE               /* 1-Byte-Alignment */
        OPTIONAL_CMD GET_DAQ_EVENT_INFO        /* List of commands supported by XCP-Gateway */ 
        OPTIONAL_CMD GET_DAQ_LIST_INFO
        OPTIONAL_CMD GET_DAQ_RESOLUTION_INFO
        OPTIONAL_CMD GET_DAQ_PROCESSOR_INFO
        OPTIONAL_CMD GET_DAQ_CLOCK
        OPTIONAL_CMD START_STOP_SYNCH
        OPTIONAL_CMD START_STOP_DAQ_LIST
        OPTIONAL_CMD GET_DAQ_LIST_MODE
        OPTIONAL_CMD SET_DAQ_LIST_MODE
        OPTIONAL_CMD WRITE_DAQ
        OPTIONAL_CMD SET_DAQ_PTR
        OPTIONAL_CMD CLEAR_DAQ_LIST
        OPTIONAL_CMD UPLOAD
        OPTIONAL_CMD WRITE_DAQ_MULTIPLE
        OPTIONAL_CMD TIME_CORRELATION_PROPERTIES
        OPTIONAL_LEVEL1_CMD GET_VERSION
        OPTIONAL_LEVEL1_CMD SET_DAQ_PACKED_MODE
        OPTIONAL_LEVEL1_CMD GET_DAQ_PACKED_MODE
      /end PROTOCOL_LAYER
      /begin DAQ
        STATIC
        0x20
        0x26
        0x00
        OPTIMISATION_TYPE_DEFAULT
        ADDRESS_EXTENSION_FREE
        IDENTIFICATION_FIELD_TYPE_RELATIVE_WORD_ALIGNED
        GRANULARITY_ODT_ENTRY_SIZE_DAQ_BYTE
        0x02
        NO_OVERLOAD_INDICATION
        /begin TIMESTAMP_SUPPORTED
          0x01
          SIZE_DWORD
          UNIT_1US
          TIMESTAMP_FIXED
        /end TIMESTAMP_SUPPORTED
        /begin DAQ_LIST
          0x00
          DAQ_LIST_TYPE DAQ
          MAX_ODT 1
          MAX_ODT_ENTRIES 150
          EVENT_FIXED 0x00
        /end DAQ_LIST
        /begin DAQ_LIST
          0x01
          DAQ_LIST_TYPE DAQ
          MAX_ODT 1
          MAX_ODT_ENTRIES 150
          EVENT_FIXED 0x01
        /end DAQ_LIST
        /begin DAQ_LIST
          0x02
          DAQ_LIST_TYPE DAQ
          MAX_ODT 1
          MAX_ODT_ENTRIES 150
          EVENT_FIXED 0x02
        /end DAQ_LIST
        /begin DAQ_LIST
          0x03
          DAQ_LIST_TYPE DAQ
          MAX_ODT 1
          MAX_ODT_ENTRIES 150
          EVENT_FIXED 0x03
        /end DAQ_LIST
        /begin DAQ_LIST
          0x04
          DAQ_LIST_TYPE DAQ
          MAX_ODT 1
          MAX_ODT_ENTRIES 150
          EVENT_FIXED 0x04
        /end DAQ_LIST
        /begin DAQ_LIST
          0x05
          DAQ_LIST_TYPE DAQ
          MAX_ODT 1
          MAX_ODT_ENTRIES 150
          EVENT_FIXED 0x05
        /end DAQ_LIST
        /begin DAQ_LIST
          0x06
          DAQ_LIST_TYPE DAQ
          MAX_ODT 1
          MAX_ODT_ENTRIES 150
          EVENT_FIXED 0x06
        /end DAQ_LIST
        /begin DAQ_LIST
          0x07
          DAQ_LIST_TYPE DAQ
          MAX_ODT 1
          MAX_ODT_ENTRIES 150
          EVENT_FIXED 0x07
        /end DAQ_LIST
        /begin DAQ_LIST
          0x08
          DAQ_LIST_TYPE DAQ
          MAX_ODT 1
          MAX_ODT_ENTRIES 150
          EVENT_FIXED 0x08
        /end DAQ_LIST
        /begin DAQ_LIST
          0x09
          DAQ_LIST_TYPE DAQ
          MAX_ODT 1
          MAX_ODT_ENTRIES 150
          EVENT_FIXED 0x09
        /end DAQ_LIST
        /begin DAQ_LIST
          0x0A
          DAQ_LIST_TYPE DAQ
          MAX_ODT 1
          MAX_ODT_ENTRIES 100
          EVENT_FIXED 0x10
        /end DAQ_LIST
        /begin DAQ_LIST
          0x0B
          DAQ_LIST_TYPE DAQ
          MAX_ODT 1
          MAX_ODT_ENTRIES 100
          EVENT_FIXED 0x11
        /end DAQ_LIST
        /begin DAQ_LIST
          0x0C
          DAQ_LIST_TYPE DAQ
          MAX_ODT 1
          MAX_ODT_ENTRIES 100
          EVENT_FIXED 0x12
        /end DAQ_LIST
        /begin DAQ_LIST
          0x0D
          DAQ_LIST_TYPE DAQ
          MAX_ODT 1
          MAX_ODT_ENTRIES 100
          EVENT_FIXED 0x13
        /end DAQ_LIST
        /begin DAQ_LIST
          0x0E
          DAQ_LIST_TYPE DAQ
          MAX_ODT 1
          MAX_ODT_ENTRIES 100
          EVENT_FIXED 0x14
        /end DAQ_LIST
        /begin DAQ_LIST
          0x0F
          DAQ_LIST_TYPE DAQ
          MAX_ODT 1
          MAX_ODT_ENTRIES 100
          EVENT_FIXED 0x15
        /end DAQ_LIST
        /begin DAQ_LIST
          0x10
          DAQ_LIST_TYPE DAQ
          MAX_ODT 1
          MAX_ODT_ENTRIES 100
          EVENT_FIXED 0x16
        /end DAQ_LIST
        /begin DAQ_LIST
          0x11
          DAQ_LIST_TYPE DAQ
          MAX_ODT 1
          MAX_ODT_ENTRIES 100
          EVENT_FIXED 0x17
        /end DAQ_LIST
        /begin DAQ_LIST
          0x12
          DAQ_LIST_TYPE DAQ
          MAX_ODT 1
          MAX_ODT_ENTRIES 100
          EVENT_FIXED 0x18
        /end DAQ_LIST
        /begin DAQ_LIST
          0x13
          DAQ_LIST_TYPE DAQ
          MAX_ODT 1
          MAX_ODT_ENTRIES 100
          EVENT_FIXED 0x19
        /end DAQ_LIST
        /begin DAQ_LIST
          0x14
          DAQ_LIST_TYPE DAQ
          MAX_ODT 1
          MAX_ODT_ENTRIES 100
          EVENT_FIXED 0x1A
        /end DAQ_LIST
        /begin DAQ_LIST
          0x15
          DAQ_LIST_TYPE DAQ
          MAX_ODT 1
          MAX_ODT_ENTRIES 100
          EVENT_FIXED 0x1B
        /end DAQ_LIST
        /begin DAQ_LIST
          0x16
          DAQ_LIST_TYPE DAQ
          MAX_ODT 1
          MAX_ODT_ENTRIES 150
          EVENT_FIXED 0x1C
          DAQ_PACKED_MODE_SUPPORTED
        /end DAQ_LIST
        /begin DAQ_LIST
          0x17
          DAQ_LIST_TYPE DAQ
          MAX_ODT 1
          MAX_ODT_ENTRIES 150
          EVENT_FIXED 0x1D
          DAQ_PACKED_MODE_SUPPORTED
        /end DAQ_LIST
        /begin DAQ_LIST
          0x18
          DAQ_LIST_TYPE DAQ
          MAX_ODT 1
          MAX_ODT_ENTRIES 150
          EVENT_FIXED 0x1E
          DAQ_PACKED_MODE_SUPPORTED
        /end DAQ_LIST
        /begin DAQ_LIST
          0x19
          DAQ_LIST_TYPE DAQ
          MAX_ODT 1
          MAX_ODT_ENTRIES 150
          EVENT_FIXED 0x1F
          DAQ_PACKED_MODE_SUPPORTED
        /end DAQ_LIST
        /begin DAQ_LIST
          0x1A
          DAQ_LIST_TYPE DAQ
          MAX_ODT 1
          MAX_ODT_ENTRIES 150
          EVENT_FIXED 0x20
          DAQ_PACKED_MODE_SUPPORTED
        /end DAQ_LIST
        /begin DAQ_LIST
          0x1B
          DAQ_LIST_TYPE DAQ
          MAX_ODT 1
          MAX_ODT_ENTRIES 150
          EVENT_FIXED 0x21
          DAQ_PACKED_MODE_SUPPORTED
        /end DAQ_LIST
        /begin DAQ_LIST
          0x1C
          DAQ_LIST_TYPE DAQ
          MAX_ODT 1
          MAX_ODT_ENTRIES 150
          EVENT_FIXED 0x22
          DAQ_PACKED_MODE_SUPPORTED
        /end DAQ_LIST
        /begin DAQ_LIST
          0x1D
          DAQ_LIST_TYPE DAQ
          MAX_ODT 1
          MAX_ODT_ENTRIES 150
          EVENT_FIXED 0x23
          DAQ_PACKED_MODE_SUPPORTED
        /end DAQ_LIST
        /begin DAQ_LIST
          0x1E
          DAQ_LIST_TYPE DAQ
          MAX_ODT 1
          MAX_ODT_ENTRIES 150
          EVENT_FIXED 0x24
          DAQ_PACKED_MODE_SUPPORTED
        /end DAQ_LIST
        /begin DAQ_LIST
          0x1F
          DAQ_LIST_TYPE DAQ
          MAX_ODT 1
          MAX_ODT_ENTRIES 150
          EVENT_FIXED 0x25
          DAQ_PACKED_MODE_SUPPORTED
        /end DAQ_LIST
        /begin EVENT
          "Event   0 - 100 us"
          "Event   0"
          0x00
          DAQ
          0x01
          100
          0x03 /* _TIME_UNIT_1US */
          0x00
        /end EVENT
        /begin EVENT
          "Event   1 - 200 us"
          "Event   1"
          0x01
          DAQ
          0x01
          2
          0x05 /* _TIME_UNIT_100US */
          0x00
        /end EVENT
        /begin EVENT
          "Event   2 - 500 us"
          "Event   2"
          0x02
          DAQ
          0x01
          5
          0x05 /* _TIME_UNIT_100US */
          0x00
        /end EVENT
        /begin EVENT
          "Event   3 - 1 ms"
          "Event   3"
          0x03
          DAQ
          0x01
          10
          0x05 /* _TIME_UNIT_100US */
          0x00
        /end EVENT
        /begin EVENT
          "Event   4 - 2 ms"
          "Event   4"
          0x04
          DAQ
          0x01
          20
          0x05 /* _TIME_UNIT_100US */
          0x00
        /end EVENT
        /begin EVENT
          "Event   5 - 5 ms"
          "Event   5"
          0x05
          DAQ
          0x01
          50
          0x05 /* _TIME_UNIT_100US */
          0x00
        /end EVENT
        /begin EVENT
          "Event   6 - 10 ms"
          "Event   6"
          0x06
          DAQ
          0x01
          100
          0x05 /* _TIME_UNIT_100US */
          0x00
        /end EVENT
        /begin EVENT
          "Event   7 - 20 ms"
          "Event   7"
          0x07
          DAQ
          0x01
          2
          0x07 /* _TIME_UNIT_10MS */
          0x00
        /end EVENT
        /begin EVENT
          "Event   8 - 50 ms"
          "Event   8"
          0x08
          DAQ
          0x01
          5
          0x07 /* _TIME_UNIT_10MS */
          0x00
        /end EVENT
        /begin EVENT
          "Event   9 - 100 ms"
          "Event   9"
          0x09
          DAQ
          0x01
          10
          0x07 /* _TIME_UNIT_10MS */
          0x00
        /end EVENT
        /begin EVENT
          "Event  10 - 200 ms"
          "Event  10"
          0x0A
          DAQ
          0x01
          20
          0x07 /* _TIME_UNIT_10MS */
          0x00
        /end EVENT
        /begin EVENT
          "Event  11 - 500 ms"
          "Event  11"
          0x0B
          DAQ
          0x01
          50
          0x07 /* _TIME_UNIT_10MS */
          0x00
        /end EVENT
        /begin EVENT
          "Event  12 - 1 s"
          "Event  12"
          0x0C
          DAQ
          0x01
          100
          0x07 /* _TIME_UNIT_10MS */
          0x00
        /end EVENT
        /begin EVENT
          "Event  13 - 100 us"
          "Event  13"
          0x0D
          DAQ
          0x01
          100
          0x03 /* _TIME_UNIT_1US */
          0x00
        /end EVENT
        /begin EVENT
          "Event  14 - 200 us"
          "Event  14"
          0x0E
          DAQ
          0x01
          2
          0x05 /* _TIME_UNIT_100US */
          0x00
        /end EVENT
        /begin EVENT
          "Event  15 - 500 us"
          "Event  15"
          0x0F
          DAQ
          0x01
          5
          0x05 /* _TIME_UNIT_100US */
          0x00
        /end EVENT
        /begin EVENT
          "Event  16 - 1 ms"
          "Event  16"
          0x10
          DAQ
          0x01
          10
          0x05 /* _TIME_UNIT_100US */
          0x00
        /end EVENT
        /begin EVENT
          "Event  17 - 2 ms"
          "Event  17"
          0x11
          DAQ
          0x01
          20
          0x05 /* _TIME_UNIT_100US */
          0x00
        /end EVENT
        /begin EVENT
          "Event  18 - 5 ms"
          "Event  18"
          0x12
          DAQ
          0x01
          50
          0x05 /* _TIME_UNIT_100US */
          0x00
        /end EVENT
        /begin EVENT
          "Event  19 - 10 ms"
          "Event  19"
          0x13
          DAQ
          0x01
          100
          0x05 /* _TIME_UNIT_100US */
          0x00
        /end EVENT
        /begin EVENT
          "Event  20 - 20 ms"
          "Event  20"
          0x14
          DAQ
          0x01
          2
          0x07 /* _TIME_UNIT_10MS */
          0x00
        /end EVENT
        /begin EVENT
          "Event  21 - 50 ms"
          "Event  21"
          0x15
          DAQ
          0x01
          5
          0x07 /* _TIME_UNIT_10MS */
          0x00
        /end EVENT
        /begin EVENT
          "Event  22 - 100 ms"
          "Event  22"
          0x16
          DAQ
          0x01
          10
          0x07 /* _TIME_UNIT_10MS */
          0x00
        /end EVENT
        /begin EVENT
          "Event  23 - 200 ms"
          "Event  23"
          0x17
          DAQ
          0x01
          20
          0x07 /* _TIME_UNIT_10MS */
          0x00
        /end EVENT
        /begin EVENT
          "Event  24 - 500 ms"
          "Event  24"
          0x18
          DAQ
          0x01
          50
          0x07 /* _TIME_UNIT_10MS */
          0x00
        /end EVENT
        /begin EVENT
          "Event  25 - 1 s"
          "Event  25"
          0x19
          DAQ
          0x01
          100
          0x07 /* _TIME_UNIT_10MS */
          0x00
        /end EVENT
        /begin EVENT
          "Event  26 - 100 us first HS"
          "Event  26"
          0x1A
          DAQ
          0x01
          100
          0x03 /* _TIME_UNIT_1US */
          0x00
        /end EVENT
        /begin EVENT
          "Event  27 - 100 us second HS"
          "Event  27"
          0x1B
          DAQ
          0x01
          100
          0x03 /* _TIME_UNIT_1US */
          0x00
        /end EVENT
        /begin EVENT
          "Event  28 - 1000 ns"
          "Event  28"
          0x1C
          DAQ
          0x01
          100
          0x01 /* _TIME_UNIT_10NS */
          0x00
          /begin DAQ_PACKED_MODE
            ELEMENT_GROUPED
            STS_LAST
            MANDATORY
            100
          /end DAQ_PACKED_MODE
        /end EVENT
        /begin EVENT
          "Event  29 - 1250 ns"
          "Event  29"
          0x1D
          DAQ
          0x01
          125
          0x01 /* _TIME_UNIT_10NS */
          0x00
          /begin DAQ_PACKED_MODE
            ELEMENT_GROUPED
            STS_LAST
            MANDATORY
            80
          /end DAQ_PACKED_MODE
        /end EVENT
        /begin EVENT
          "Event  30 - 2000 ns"
          "Event  30"
          0x1E
          DAQ
          0x01
          20
          0x02 /* _TIME_UNIT_100NS */
          0x00
          /begin DAQ_PACKED_MODE
            ELEMENT_GROUPED
            STS_LAST
            MANDATORY
            50
          /end DAQ_PACKED_MODE
        /end EVENT
        /begin EVENT
          "Event  31 - 2500 ns"
          "Event  31"
          0x1F
          DAQ
          0x01
          25
          0x02 /* _TIME_UNIT_100NS */
          0x00
          /begin DAQ_PACKED_MODE
            ELEMENT_GROUPED
            STS_LAST
            MANDATORY
            40
          /end DAQ_PACKED_MODE
        /end EVENT
        /begin EVENT
          "Event  32 - 5000 ns"
          "Event  32"
          0x20
          DAQ
          0x01
          50
          0x02 /* _TIME_UNIT_100NS */
          0x00
          /begin DAQ_PACKED_MODE
            ELEMENT_GROUPED
            STS_LAST
            MANDATORY
            20
          /end DAQ_PACKED_MODE
        /end EVENT
        /begin EVENT
          "Event  33 - 10000 ns"
          "Event  33"
          0x21
          DAQ
          0x01
          100
          0x02 /* _TIME_UNIT_100NS */
          0x00
          /begin DAQ_PACKED_MODE
            ELEMENT_GROUPED
            STS_LAST
            MANDATORY
            10
          /end DAQ_PACKED_MODE
        /end EVENT
        /begin EVENT
          "Event  34 - 12500 ns"
          "Event  34"
          0x22
          DAQ
          0x01
          125
          0x02 /* _TIME_UNIT_100NS */
          0x00
          /begin DAQ_PACKED_MODE
            ELEMENT_GROUPED
            STS_LAST
            MANDATORY
            8
          /end DAQ_PACKED_MODE
        /end EVENT
        /begin EVENT
          "Event  35 - 20 us"
          "Event  35"
          0x23
          DAQ
          0x01
          20
          0x03 /* _TIME_UNIT_1US */
          0x00
          /begin DAQ_PACKED_MODE
            ELEMENT_GROUPED
            STS_LAST
            MANDATORY
            5
          /end DAQ_PACKED_MODE
        /end EVENT
        /begin EVENT
          "Event  36 - 25 us"
          "Event  36"
          0x24
          DAQ
          0x01
          25
          0x03 /* _TIME_UNIT_1US */
          0x00
          /begin DAQ_PACKED_MODE
            ELEMENT_GROUPED
            STS_LAST
            MANDATORY
            4
          /end DAQ_PACKED_MODE
        /end EVENT
        /begin EVENT
          "Event  37 - 50 us"
          "Event  37"
          0x25
          DAQ
          0x01
          50
          0x03 /* _TIME_UNIT_1US */
          0x00
          /begin DAQ_PACKED_MODE
            ELEMENT_GROUPED
            STS_LAST
            MANDATORY
            2
          /end DAQ_PACKED_MODE
        /end EVENT
      /end DAQ
      /begin PAG
        0x00
      /end PAG
      /begin PGM
        PGM_MODE_ABSOLUTE
        0x00
        0x00
      /end PGM
      /begin TIME_CORRELATION
        DAQ_TIMESTAMPS_RELATE_TO XCP_SLAVE_CLOCK
        /begin CLOCK
          0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00
          XCP_SLAVE_CLOCK
          RANDOMLY_READABLE
          SYN_ALL
          0x00
          /begin TIMESTAMP_CHARACTERIZATION
            1
            UNIT_1US
            SIZE_EIGHT_BYTE
          /end TIMESTAMP_CHARACTERIZATION
          0xFFFFFFFFFFFFFFFF
          UNIVERSAL_COORDINATED_TIME
        /end CLOCK
      /end TIME_CORRELATION
      /begin XCP_ON_UDP_IP
        0x0104
        5555
        ADDRESS "172.31.31.242"
        MAX_BUS_LOAD  90
        MAX_BIT_RATE  100
        PACKET_ALIGNMENT PACKET_ALIGNMENT_16
        OPTIONAL_TL_SUBCMD GET_SLAVE_ID
        OPTIONAL_TL_SUBCMD GET_SLAVE_ID_EXTENDED
        OPTIONAL_TL_SUBCMD SET_SLAVE_IP_ADDRESS
        OPTIONAL_TL_SUBCMD GET_DAQ_CLOCK_MULTICAST
      /end XCP_ON_UDP_IP
    /end IF_DATA
    
    /begin IF_DATA CSM_X07 12
      /begin GATEWAY
        "255.255.255.0"
        SNO 539
        MULTIECAT MULTIECAT_10KHZ
        SYNC_EVT_CFG 0x40 0x01
        PTP_CFG 0x00 0x00 2 0x03
        /begin PTP_INFO
          0 0 0 0 0
          0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00
          0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00
          0 0 0 0
          0 0 0
        /end PTP_INFO
      /end GATEWAY
      /begin BUS "ECAT1" 0x03
        BUS_ETHERCAT
      /end BUS
      /begin DEVICE "ADMMEC_23873" "ADMMEC_23873"
        "ECAT1" 23873 "" 3002 23
        0x03 4 50152
        DEVICEPROPS 0x42303731 0x0210 0x00014571 0xA0 0x00000881
        CONFIGHASH 0x4C04B1AF
        BYTE_ORDER MSB_LAST
      /end DEVICE
      /begin CHANNEL "ADMMEC_23873_A01"
        "ADMMEC_23873" 1
        0x03 5 0 BIPOLAR
        FILTER 2 0
        LINSCALE 0.00015262515299999999 0
        DISPSCALE "V" -5 5
        SENSSUPPLY 0
        INTERNAL_ADJUST 0
        TEDScontrol 1 1 4223627021
      /end CHANNEL
      /begin CHANNEL "ADMMEC_23873_A02"
        "ADMMEC_23873" 2
        0x03 5 0 BIPOLAR
        FILTER 2 0
        LINSCALE 0.00015262515299999999 0
        DISPSCALE "V" -5 5
        SENSSUPPLY 0
        INTERNAL_ADJUST 0
        TEDScontrol 1 1 868266956
      /end CHANNEL
      /begin CHANNEL "UBatt"
        "ADMMEC_23873" 3
        0x03 45 0 BIPOLAR
        FILTER 2 0
        LINSCALE 0.00137362637 0
        DISPSCALE "V" -45 45
        SENSSUPPLY 0
        INTERNAL_ADJUST 0
        TEDScontrol 1 1 829482907
      /end CHANNEL
      /begin CHANNEL "IBatt"
        "ADMMEC_23873" 4
        0x03 5 0 BIPOLAR
        FILTER 2 0
        LINSCALE -0.00152625153 0
        DISPSCALE "A" -5 5
        SENSSUPPLY 5.0
        INTERNAL_ADJUST 0
        TEDScontrol 1 1 236384753
      /end CHANNEL
    /end IF_DATA
    
    /begin MOD_COMMON "XCPGateway"
      BYTE_ORDER MSB_LAST
      ALIGNMENT_BYTE 1
      ALIGNMENT_WORD 2
      ALIGNMENT_LONG 4
      ALIGNMENT_INT64 8
      ALIGNMENT_FLOAT32_IEEE 4
      ALIGNMENT_FLOAT64_IEEE 8
    /end MOD_COMMON
    
    /begin COMPU_VTAB CSM_ADMM_SWORD_STATES "CSM_ADMM_SWORD_STATES"
      TAB_VERB 1
      -32768    "OUT_OF_RANGE"
    /end COMPU_VTAB
    
    /begin COMPU_VTAB CSM_ADMM_UWORD_STATES "CSM_ADMM_UWORD_STATES"
      TAB_VERB 1
      65535     "OUT_OF_RANGE"
    /end COMPU_VTAB
    
    /begin COMPU_VTAB CSM_THMM_UWORD_STATES "CSM_THMM_UWORD_STATES"
      TAB_VERB 1
      0         "NO_SENSOR"
    /end COMPU_VTAB
    
    /begin COMPU_VTAB CSM_THMM_SWORD_STATES "CSM_THMM_SWORD_STATES"
      TAB_VERB 1
      -32768    "NO_SENSOR"
    /end COMPU_VTAB
    
    /begin COMPU_VTAB CSM_PTMM_UWORD_STATES "CSM_PTMM_UWORD_STATES"
      TAB_VERB 1
      65535     "NO_SENSOR"
    /end COMPU_VTAB
    
    /begin COMPU_VTAB CSM_PTMM_SWORD_STATES "CSM_THMM_SWORD_STATES"
      TAB_VERB 1
      -32768    "NO_SENSOR"
    /end COMPU_VTAB
    
    /begin COMPU_VTAB CSM_CNMM0_UWORD_STATES "CSM_CNMM0_UWORD_STATES"
      TAB_VERB 2
      0         "TIME_OUT"
      65535     "OVERFLOW"
    /end COMPU_VTAB
    
    /begin COMPU_VTAB CSM_CNMM1_UWORD_STATES "CSM_CNMM1_UWORD_STATES"
      TAB_VERB 2
      0         "PERIOD_TOO_SMALL"
      65535     "TIME_OUT"
    /end COMPU_VTAB
    
    /begin COMPU_VTAB CSM_CNMM8_UWORD_STATES "CSM_CNMM8_UWORD_STATES"
      TAB_VERB 1
      65535     "OVERFLOW"
    /end COMPU_VTAB
    
    /begin COMPU_VTAB CSM_CNMM20_SWORD_STATES "CSM_CNMM20_SWORD_STATES"
      TAB_VERB 3
      -32768    "UNDERFLOW"
      0         "TIME_OUT"
      32767    "OVERFLOW"
    /end COMPU_VTAB
    
    /begin COMPU_VTAB CSM_CNMM21_SWORD_STATES "CSM_CNMM21_SWORD_STATES"
      TAB_VERB 2
      -32768    "UNDERFLOW"
      32767    "OVERFLOW"
    /end COMPU_VTAB
    
    /begin COMPU_VTAB CSM_STGMM_SWORD_STATES "CSM_STGMM_SWORD_STATES"
      TAB_VERB 15
      32767 "ERROR_7FFF"
      32766 "ERROR_7FFE"
      32765 "ERROR_7FFD"
      32764 "ERROR_7FFC"
      32763 "EXCITATION_RANGE_OVERFLOW"
      32762 "INPUT_RANGE_OVERFLOW"
      32761 "MEASUREMENT_RANGE_OVERFLOW"
      -32761 "MEASUREMENT_RANGE_UNDERFLOW"
      -32762 "INPUT_RANGE_UNDERFLOW"
      -32763 "EXCITATION_RANGE_UNDERFLOW"
      -32764 "ERROR_8004"
      -32765 "ERROR_8003"
      -32766 "ERROR_8002"
      -32767 "ERROR_8001"
      -32768 "EXCITATION_ERROR"
    /end COMPU_VTAB
    
    /begin COMPU_VTAB CSM_ECATADMMHS_SWORD_STATES "CSM_ECATADMMHS_SWORD_STATES"
      TAB_VERB 15
      32767 "ERROR_7FFF"
      32766 "ERROR_7FFE"
      32765 "ERROR_7FFD"
      32764 "INVALID_TEDS"
      32763 "EXCITATION_RANGE_OVERFLOW"
      32762 "INPUT_RANGE_OVERFLOW"
      32761 "MEASUREMENT_RANGE_OVERFLOW"
      -32761 "MEASUREMENT_RANGE_UNDERFLOW"
      -32762 "INPUT_RANGE_UNDERFLOW"
      -32763 "EXCITATION_RANGE_UNDERFLOW"
      -32764 "ERROR_8004"
      -32765 "ERROR_8003"
      -32766 "ERROR_8002"
      -32767 "ERROR_8001"
      -32768 "ERROR_8000"
    /end COMPU_VTAB
    
    /begin COMPU_VTAB CSM_HVBM_SWORD_STATES "CSM_HVBM_SWORD_STATES"
      TAB_VERB 15
      32767 "ERROR_7FFF"
      32766 "ERROR_7FFE"
      32765 "ERROR_7FFD"
      32764 "ERROR_7FFC"
      32763 "ERROR_7FFB"
      32762 "INPUT_RANGE_OVERFLOW"
      32761 "MEASUREMENT_RANGE_OVERFLOW"
      -32761 "MEASUREMENT_RANGE_UNDERFLOW"
      -32762 "INPUT_RANGE_UNDERFLOW"
      -32763 "ERROR_8005"
      -32764 "SHUNT_ERROR"
      -32765 "ERROR_8003"
      -32766 "ERROR_8002"
      -32767 "ERROR_8001"
      -32768 "CONFIGURATION_ERROR"
    /end COMPU_VTAB
    
    /* Channel ADMMEC_23873_A01 */
    
    /begin MEASUREMENT ADMMEC_23873_A01 ""
      SWORD CNV_ADMMEC_23873_A01 0 0 -5 5
      ECU_ADDRESS 0x5D411700
      ECU_ADDRESS_EXTENSION 0x00
      BYTE_ORDER MSB_LAST
      /begin IF_DATA XCPplus 0x0104
        /begin DAQ_EVENT VARIABLE
          /begin AVAILABLE_EVENT_LIST
            EVENT 0x1C
          /end AVAILABLE_EVENT_LIST
          /begin DEFAULT_EVENT_LIST
            EVENT 0x1C
          /end DEFAULT_EVENT_LIST
        /end DAQ_EVENT
      /end IF_DATA
      /begin ANNOTATION
        ANNOTATION_LABEL "UserFactor"
        /begin ANNOTATION_TEXT
          "1"
        /end ANNOTATION_TEXT
      /end ANNOTATION
      /begin ANNOTATION
        ANNOTATION_LABEL "UserOffset"
        /begin ANNOTATION_TEXT
          "0"
        /end ANNOTATION_TEXT
      /end ANNOTATION
    /end MEASUREMENT
    
    /begin COMPU_METHOD CNV_ADMMEC_23873_A01 "CNV_ADMMEC_23873_A01"
      RAT_FUNC "%8.6" "V"
      COEFFS 0 1 0 0 0 0.00015262515299999999
      STATUS_STRING_REF CSM_ECATADMMHS_SWORD_STATES
    /end COMPU_METHOD
    
    /* Channel ADMMEC_23873_A02 */
    
    /begin MEASUREMENT ADMMEC_23873_A02 ""
      SWORD CNV_ADMMEC_23873_A02 0 0 -5 5
      ECU_ADDRESS 0x5D411710
      ECU_ADDRESS_EXTENSION 0x00
      BYTE_ORDER MSB_LAST
      /begin IF_DATA XCPplus 0x0104
        /begin DAQ_EVENT VARIABLE
          /begin AVAILABLE_EVENT_LIST
            EVENT 0x1C
          /end AVAILABLE_EVENT_LIST
          /begin DEFAULT_EVENT_LIST
            EVENT 0x1C
          /end DEFAULT_EVENT_LIST
        /end DAQ_EVENT
      /end IF_DATA
      /begin ANNOTATION
        ANNOTATION_LABEL "UserFactor"
        /begin ANNOTATION_TEXT
          "1"
        /end ANNOTATION_TEXT
      /end ANNOTATION
      /begin ANNOTATION
        ANNOTATION_LABEL "UserOffset"
        /begin ANNOTATION_TEXT
          "0"
        /end ANNOTATION_TEXT
      /end ANNOTATION
    /end MEASUREMENT
    
    /begin COMPU_METHOD CNV_ADMMEC_23873_A02 "CNV_ADMMEC_23873_A02"
      RAT_FUNC "%8.6" "V"
      COEFFS 0 1 0 0 0 0.00015262515299999999
      STATUS_STRING_REF CSM_ECATADMMHS_SWORD_STATES
    /end COMPU_METHOD
    
    /* Channel UBatt */
    
    /begin MEASUREMENT UBatt ""
      SWORD CNV_UBatt 0 0 -45 45
      ECU_ADDRESS 0x5D411720
      ECU_ADDRESS_EXTENSION 0x00
      BYTE_ORDER MSB_LAST
      /begin IF_DATA XCPplus 0x0104
        /begin DAQ_EVENT VARIABLE
          /begin AVAILABLE_EVENT_LIST
            EVENT 0x1C
          /end AVAILABLE_EVENT_LIST
          /begin DEFAULT_EVENT_LIST
            EVENT 0x1C
          /end DEFAULT_EVENT_LIST
        /end DAQ_EVENT
      /end IF_DATA
      /begin ANNOTATION
        ANNOTATION_LABEL "UserFactor"
        /begin ANNOTATION_TEXT
          "1"
        /end ANNOTATION_TEXT
      /end ANNOTATION
      /begin ANNOTATION
        ANNOTATION_LABEL "UserOffset"
        /begin ANNOTATION_TEXT
          "0"
        /end ANNOTATION_TEXT
      /end ANNOTATION
    /end MEASUREMENT
    
    /begin COMPU_METHOD CNV_UBatt "CNV_UBatt"
      RAT_FUNC "%8.6" "V"
      COEFFS 0 1 0 0 0 0.00137362637
      STATUS_STRING_REF CSM_ECATADMMHS_SWORD_STATES
    /end COMPU_METHOD
    
    /* Channel IBatt */
    
    /begin MEASUREMENT IBatt ""
      SWORD CNV_IBatt 0 0 -5 5
      ECU_ADDRESS 0x5D411730
      ECU_ADDRESS_EXTENSION 0x00
      BYTE_ORDER MSB_LAST
      /begin IF_DATA XCPplus 0x0104
        /begin DAQ_EVENT VARIABLE
          /begin AVAILABLE_EVENT_LIST
            EVENT 0x1C
          /end AVAILABLE_EVENT_LIST
          /begin DEFAULT_EVENT_LIST
            EVENT 0x1C
          /end DEFAULT_EVENT_LIST
        /end DAQ_EVENT
      /end IF_DATA
      /begin ANNOTATION
        ANNOTATION_LABEL "UserFactor"
        /begin ANNOTATION_TEXT
          "-10"
        /end ANNOTATION_TEXT
      /end ANNOTATION
      /begin ANNOTATION
        ANNOTATION_LABEL "UserOffset"
        /begin ANNOTATION_TEXT
          "0"
        /end ANNOTATION_TEXT
      /end ANNOTATION
    /end MEASUREMENT
    
    /begin COMPU_METHOD CNV_IBatt "CNV_IBatt"
      RAT_FUNC "%8.6" "A"
      COEFFS 0 1 0 0 0 -0.00152625153
      STATUS_STRING_REF CSM_ECATADMMHS_SWORD_STATES
    /end COMPU_METHOD
    
    /begin GROUP EtherCAT "EtherCAT measurements"
      ROOT
      /begin SUB_GROUP
        ADMMEC_23873
      /end SUB_GROUP
    /end GROUP
    
    /begin GROUP ADMMEC_23873 "ADMMEC_23873 measurements"
      /begin REF_MEASUREMENT
        ADMMEC_23873_A01
        ADMMEC_23873_A02
        UBatt
        IBatt
      /end REF_MEASUREMENT
    /end GROUP
    
    
  /end MODULE
/end PROJECT
